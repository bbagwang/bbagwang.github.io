---
title: "Game Server Development #5 : Lock Implementation Theory"
summary: "Dead Lock"
categories: ["Korean Post", "Programming"]
tags: ["C++", "Server", "Thread", "Lock"]
date: 2023-09-04
draft: false
showauthor: false
authors:
  - bbagwang
series: ["Game Server Development"]
series_order: 5
---

## Material
**[[C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버](https://inf.run/8Chk)**

## Spin Lock

`Spinlock` 은 이름에서 알 수 있듯이, 자원에 접근할 수 있을 때까지 계속해서 `Spin(Loop)` 하는 락이다.

`Spinlock`은 굉장히 빠르게 작동하므로, 락을 획득하고 해제하는 작업이 매우 빠르게 이루어질 것이라고 예상되는 상황에서 효율적이다.

반대로 락을 획득하는 데 오랜 시간이 걸리는 경우에는 CPU 자원을 불필요하게 낭비하게 된다.

락을 획득할 때 까지 존버 하는 메타라고 보면 된다.

### Busy-Waiting

`Spinlock`은 락을 얻을 수 있을 때까지 계속 CPU를 사용한다. 그래서 CPU 시간을 낭비할 수 있다.

### Priority Inversion

높은 우선 순위의 스레드가 낮은 우선 순위의 스레드를 기다리게 되면 효율성이 떨어질 수 있다.

## Backoff Lock

백오프(Backoff) 는 한 발 물러선다는 뜻이다.

랜덤하게나 일정 시간마다 락의 상태를 확인하는 전략을 이용하는 락이다.

`Spinlock` 의 문제점인 `Busy Waiting` 문제를 완화하기 위해 사용한다.

락을 얻지 못할 경우 잠시 대기하고, 그 대기 시간을 최소, 최대 기간 범위 내에서 랜덤하게 증가시키는 방식이다.

이렇게 하면 여러 스레드가 동시에 락을 획득하려고 할 때 발생하는 `contention (경쟁 상태)` 을 줄일 수 있다.

백오프 전략은 시스템의 전체 성능에 도움을 줄 수 있지만, 어떤 상황에서는 락을 획득하는데 필요한 시간이 늘어나게 할 수도 있다.

실제 시스템에서 어떻게 동작하는지 테스트하고 적절한 최소, 최대 값을 선택하는 것이 중요하다.

## Event (Notify) Lock

특정 락이 풀리면, 그 락을 잡기 위해 대기중인 스레드들에게 이벤트를 전달해서 깨우는 방식도 있다.

락 풀리면 너(운영체제) 가 알려줘 하고 자러가는 갑질 메타 라고 볼 수 있다.

## Context Switch

컨텍스트 스위칭은 운영체제의 스케줄러가 CPU를 다른 프로세스 또는 스레드에 할당하기 위해 현재 실행 중인 프로세스 또는 스레드의 상태를 저장하고 다른 프로세스 또는 스레드의 *상태를 복원하는 과정*을 의미한다.

이렇게 함으로써, 단일 CPU에서 여러 프로세스 또는 스레드가 동시에 실행되는 것처럼 보이게 된다.

이 과정은 당연하게 느껴지면서도, 신경써야 할 점들이 있다.

### Overhead

컨텍스트 스위칭은 CPU가 다른 작업을 수행할 수 있는 시간을 소모한다.

특히 고성능이 필요한 애플리케이션에서 잦은 컨텍스트 스위칭은 문제가 될 수 있다.

### Cache Invalidation

프로세스 또는 스레드가 변경될 때, CPU 캐시에 있던 데이터가 무효화될 수 있다.

`Cache Miss` 가 빈번하게 발생하면 성능이 저하될 수 있다.

## User <-> Kernel Mode

유저 모드 (User Mode)와 커널 모드 (Kernel Mode)는 운영체제와 프로세스가 CPU에서 명령을 실행할 때의 두 가지 주요 실행 모드다.

이 두 모드는 시스템의 안정성과 보안을 보장하는 데 중요한 역할을 한다.

컴퓨터 시스템의 안정성과 보안을 위해 일반적인 애플리케이션들이 직접적으로 하드웨어에 액세스하는 것을 제한하기 때문이다.

이 구분을 통해 잘못된 애플리케이션 코드나 악의적인 코드가 전체 시스템을 손상시키는 것을 방지한다.

시스템 호출을 통해 유저 모드에서 커널 모드로 전환되는 것은 오버헤드가 있다.

유저 프로세스와 커널 간의 정보를 저장하고 복원해야 하기 때문이다.

빈번한 모드 전환이 성능에 부정적인 영향을 줄 수 있다.

### User Mode

프로세스가 자신의 메모리 공간에서 실행되는 모드다.

유저 모드에서 실행되는 프로세스는 직접적으로 하드웨어 자원에 액세스할 수 없다.

제한된 명령만 실행할 수 있으며, 보다 높은 권한이 필요한 작업을 수행하려면 커널 모드로 전환되어야 한다.

예를 들어, 파일을 읽거나 쓰려면 운영체제에 요청을 하고, 이 요청은 커널 모드에서 처리된다.

`Spinlock` 은 유저 모드에서 계속 실행시켜둘 수 있지만, `Backoff` 나 `Notify` 를 이용할 경우, 커널 모드로 전환하여 작업하여야 한다.

### Kernel Mode

운영체제의 핵심 부분이 실행되는 모드다.

커널 모드에서는 모든 CPU 명령과 하드웨어 자원에 접근할 수 있다.

유저 모드에서는 수행할 수 없는 시스템 호출 (예: I/O 요청, 프로세스 관리, 메모리 관리, 스레드 관리 등)을 수행할 때 커널 모드로 전환된다.

이 모드에서 오류가 발생하면 시스템 전체에 영향을 미칠 수 있다.

