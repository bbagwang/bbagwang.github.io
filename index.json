[{"content":" ","date":"2023-11-12","permalink":"/","section":"","summary":" ","title":""},{"content":"","date":"2023-11-12","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"2023-11-12","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"2023-11-12","permalink":"/categories/korean-post/","section":"Categories","summary":"","title":"Korean Post"},{"content":"","date":"2023-11-12","permalink":"/tags/lua/","section":"Tags","summary":"","title":"Lua"},{"content":"","date":"2023-11-12","permalink":"/series/lua-tonic/","section":"Series","summary":"","title":"Lua Tonic"},{"content":"Lua 를 이용해 가장 먼저 해볼 것은 언어 학습의 국룰인 Hello World! 를 출력하는 것이다.\n나는 루아를 배우기 시작한 만큼, Hello Lua! 를 출력해보려 한다.\n그런데 일단 루아가 없다. 설치부터 진행해 보도록 하자.\nDisclaimer\n아래 내용은 정석적이긴 하지만, 꽤나 귀찮은 방식이긴 하다.\n좀 더 빠르고 간편하게 루아를 설치하고 싶다면 homebrew 같은 것을 사용하는 것도 좋다.\nInstall Lua # 내가 평소에 사용하는 머신은 2 가지 이다.\nMacBook Pro M1 (Mac OS) HanSung TFX5075G (Windows 11) 두 노트북은 서로 다른 OS 를 사용하고, 루아를 설치하는 방법도 약간 다르다.\n노트북을 번갈아 가면서 글을 쓰게될 것이므로, 각각의 OS 에 맞는 설치 방법을 적어두겠다.\n현재 이 글을 쓰는 기준에서 가장 최신 버전인 5.4.6 버전의 루아를 설치하도록 한다.\nMac # Terminal 을 연다.\ncd 명령어를 이용해 루아를 다운로드할 디렉토리로 이동한다.\n나는 Downloads 폴더를 추천한다.\n명령어를 이용해 루아를 다운로드 받는다.\ncurl -R -O http://www.lua.org/ftp/lua-5.4.6.tar.gz 그 후 받아온 파일을 압축 해제한다.\ntar zxf lua-5.4.6.tar.gz ls 명령어로 파일 리스트를 보면 lua-5.4.6 이라는 폴더가 생성되어 있는 것을 확인할 수 있다.\ncd lua-5.4.6 으로 해당 폴더로 이동한다.\n다시 ls 명령어를 사용해보면, 압축을 해제한 폴더에 무엇이 있는지 확인할 수 있다.\n여기서 MakeFile 이라는 파일이 있는 것을 확인할 수 있다.\n이 파일은 루아를 빌드하고 설치하는 데 사용된다.\n아래의 명령어를 입력해 루아를 빌드하고, 설치하자.\nsudo make all install 큰 문제 없이 설치가 되었다면, lua 를 입력해 루아가 설치되었는지 확인해보자.\n다음과 같은 메시지가 출력된다면, 빌드와 설치에 성공한 것이다.\nLua 5.4.6 Copyright (C) 1994-2023 Lua.org, PUC-Rio \u0026gt; 가 출력되며 인터프리터가 실행되어 있다면, Control + C 를 눌러 나올 수 있다.\nWindows # 윈도우즈에서 루아를 직접 빌드하고, 적용하는 것은 조금 복잡하다.\n일단 make 부터 동작하지 않을 것이기 때문이다.\n그래서 미리 빌드된 루아를 다운로드 받아서 사용하도록 하는 것이 속 편하다.\nhttps://joedf.ahkscript.org/LuaBuilds/\n위 링크로 들어가면, 미리 빌드된 루아 바이너리를 다운로드 받을 수 있다.\nlua-5.4.6_Win64_bin.zip 를 다운로드 받아서, 압축을 해제한다.\n압축을 해제한 폴더의 이름을 lua 로 변경한다.\nC:\\Program Files 위치에 lua 폴더를 이동시킨다.\n그럼 최종적으로 C:\\Program Files\\lua 경로에 압축을 해제한 내용이 들어있을 것이다.\n이제 lua 폴더의 경로를 환경 변수에 추가해야 한다.\n시스템 환경 변수 편집 을 메뉴에서 검색해 실행한다.\n오른쪽 아래 환경 변수 를 클릭한다.\n시스템 변수 에서 Path 를 찾아서 편집한다.\n새로 만들기 를 클릭하고, C:\\Program Files\\lua 를 입력한다.\n확인 을 눌러서 저장한다.\n이제 cmd 를 열고, lua 를 입력해보자.\n다음과 같은 메시지가 출력된다면, 빌드와 설치에 성공한 것이다.\nLua 5.4.6 Copyright (C) 1994-2023 Lua.org, PUC-Rio \u0026gt; 가 출력되며 인터프리터가 실행되어 있다면, Control + C 를 눌러 나올 수 있다.\nHello Lua! # 이제 루아를 설치했으니, Hello World! 를 출력해보자.\nTerminal 혹은 cmd 를 열고, lua 를 입력해 인터프리터를 실행한다.\n그리고 다음과 같이 입력해보자.\nprint(\u0026#34;Hello Lua!\u0026#34;) 그럼 다음과 같이 출력된다.\nHello Lua! 여기까지 루아를 설치해 보고, 간단한 출력 테스트를 진행해 보았다.\nVisual Studio Code # 앞으로 사용할 코드 에디터는 Visual Studio Code 다.\n확장을 설치하면 개발이 편해지므로, 확장 탭에서 Lua 를 검색해서 아래의 확장을 설치하면 된다.\nhttps://marketplace.visualstudio.com/items?itemName=sumneko.lua\n","date":"2023-11-12","permalink":"/posts/luatonic/1-hellolua/","section":"Posts","summary":"Hello Lua!","title":"Lua Tonic #1 : Hello Lua"},{"content":"","date":"2023-11-12","permalink":"/tags/programming/","section":"Tags","summary":"","title":"Programming"},{"content":"","date":"2023-11-12","permalink":"/categories/programming/","section":"Categories","summary":"","title":"Programming"},{"content":"","date":"2023-11-12","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"2023-11-12","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":" Introduction # 어린 시절, 온라인 게임만 하던 나는 이마트에서 난생 처음 Orange Box 라는 패키지 게임을 샀었다.\n주황색 상자가 이뻐보였고, 게임이 3개나 들었다고 하니 부모님을 졸라서 샀던 기억이 난다.\n다른 게임들 모두 너무 재미있었지만, 패키지에 들어있던 Team Fortress 2 라는 게임을 접하고, 나는 결국 꿈을 정하게 되었던 것 같다.\n왜냐하면, Team Fortress 2 는 내가 초등학생 때 부터, 고등학교를 졸업 할 때 까지 정말 즐겁게 그리고 열정적으로 MOD 서버를 개발 및 운영했던 게임이기 때문이다.\n서버를 운영하면서, 유저들이 내가 만든 무언가를 이용하며 재미있게 노는 것을 보는 뿌듯함은 정말 최고였다.\n이런 저런 생각지 못한 부분이나 아쉬운 점에 대한 피드백을 받으며, 고쳐진 부분을 만족해 하는 모습을 보는 것 또한 즐거웠다.\n점점 게임을 플레이 하는 것 보다, 게임에 무언가 만드는 것이 더 즐거워졌다.\n그렇게 살다보니, 아직 너무나 많이 부족하지만, 나는 결국 게임 개발자가 되어있었다.\n이처럼 원하는 대로 자유롭게 게임을 모딩 할 수 있고, 그것을 선보일 수 있는 게임의 환경은 누군가에겐 확고한 꿈을 정해줄 만큼 매력적인 기능으로 다가올 수 있다.\n그래서 나도 개인 토이 프로젝트로 Unreal Engine 에서 사용 가능한 Lua 스크립팅 언어 지원 Plugin 을 만들어 보고자 한다.\n이미 여러 구현들이 존재하고, 판매까지 되고 있지만, 나는 처음부터 직접 만들어 보는 경험과 개발 능력 향상을 위한 공부를 위해 직접 개발 해보려 한다.\n이번 기회에 루아를 제대로 공부해보고, 플러그인을 만들어보며 언리얼 엔진의 일부 구조도 알아보며, 궁극적으로는 다양한 프로젝트에서 편하게 사용할 수 있는 스크립팅 기능을 만들어보는 것이 목표다.\n아마 시간 날 때, 짬짬히 공부하면서 만드는 것이니, 긴 시간이 걸릴 것 같지만, 그래도 재미있을 것 같아서 시작해보려 한다.\nWhat is Lua? # 루아는 내부적으로 C 언어로 작성되어 있으며, C 와 C++ 언어에서 사용할 수 있다.\n루아는 임베디드 가능한 스크립팅 언어 (Embeddable Scripting Language) 이다.\n임베더블? 스크립팅? 헷갈리니 의미를 나눠서 알아보자.\nEmbeddable Language # Embed 는 포함시킨다는 뜻이다.\nEmbeddable 은 Embed 가 Able 하다는 뜻이다.\n그러므로 다른 프로그램 안에 포함 또는 통합될 수 있는 언어 라는 뜻이다.\n이런 언어는 프로그램의 기능을 확장하거나, 사용자 정의 스크립트를 통해 프로그램의 행동을 변경할 수 있게 해준다.\n간단한 예로 Garry's Mod 라는 게임에서 Modding 기능 제공을 위해 루아를 Embed 하여 사용하고 있다.\nScripting Language # 스크립트 언어는 프로그래밍 언어의 한 유형이다.\n주로 간결하고, 사용이 쉬우며, 빠른 개발을 가능하게 하는 것이 특징이다.\n스크립트 언어의 일반적인 특징을 쉽게 설명하자면 다음과 같다.\nInterpreted # 스크립트 언어는 대부분 인터프리터(Interpreter) 를 통해 실행된다.\n실행될 때마다 소스 코드가 해석되어 실행된다는 의미이다.\nSimple Syntax # 스크립트 언어는 간결하고 이해하기 쉬운 문법을 가지고 있다.\n그래서 개발자들은 더 빠르고 효율적으로 코드를 작성할 수 있다.\nHigh Level Features # 많은 스크립트 언어들은 파일 처리, 네트워킹, 데이터베이스 접근과 같은 고수준의 기능을 내장하고 있다.\n그래서 개발자들은 복잡한 작업을 손쉽게 처리할 수 있다.\nDynamic Typing # 스크립트 언어는 대부분 동적 타입(Dynamic Type) 을 사용한다.\n동적 타입이란, 변수의 타입을 미리 선언하지 않고, 변수에 값을 할당할 때, 그 값의 타입에 따라 자동으로 타입이 결정되는 것을 말한다.\n그러므로, 변수의 타입을 미리 선언할 필요가 없으며, 같은 변수에 다른 타입의 데이터를 할당할 수도 있다.\nAutomatic Memory Management # 스크립트 언어는 대부분 가비지 컬렉션(garbage collection) 같은 자동 메모리 관리 기능을 제공한다.\n이로 인해 개발자는 메모리 할당 및 해제를 신경 쓸 필요가 없어진다.\nPlatform Independent # 많은 스크립트 언어들은 다양한 플랫폼에서 실행될 수 있다.\nLua 와 더불어, Python 이나 JavaScript 같은 언어들도 여러 운영 체제에서 동일한 방식으로 작동한다.\nWhy Lua? # Lua 가 공식 사이트에서 사용해야 하는 이유를 다음과 같이 설명하고 있다.\nLua is a proven, robust language # 루아는 1993년 이래로 여러 버전이 실제 애플리케이션에서 사용되어 왔다.\nAdobe의 Photoshop Lightroom, 디지털 TV용 Ginga 미들웨어, 게임(World of Warcraft, Angry Birds) 등 다양한 산업 분야에서 사용되고 있다.\n게임 분야에서 주도적인 스크립트 언어로 자리 잡았다.\nLua is fast # 루아는 해석되는 스크립트 언어 중에서 최고의 성능을 자랑한다.\n벤치마크 결과뿐만 아니라 실제 애플리케이션에서도 빠른 속도를 보인다.\n더 빠른 속도가 필요하다면, JIT 컴파일러를 사용하는 LuaJIT 을 사용할 수 있다.\nLua is portable # 루아는 작은 패키지로 제공되며 표준 C 컴파일러가 있는 모든 플랫폼에서 쉽게 빌드된다.\nUnix 및 Windows의 모든 버전, 다양한 모바일 기기, 임베디드 마이크로프로세서, IBM 메인프레임 등에서 작동한다.\nLua is embeddable # 루아는 작은 메모리를 사용한다.\n다른 언어로 작성된 코드와 강력한 통합을 가능하게 하는 간단하고 잘 문서화된 API를 가지고 있어, 어플리케이션에 쉽게 내장할 수 있다.\nLua is powerful (but simple) # 루아는 언어 자체에 많은 기능을 직접 제공하기보다는 기능을 구현하기 위한 메타-메커니즘을 제공한다.\n이는 언어를 작게 유지하면서도 비전통적인 방식으로 의미론을 확장할 수 있게 한다.\nLua is small # 루아를 애플리케이션에 추가해도 프로그램이 커지지 않는다.\n소스 코드와 문서가 포함된 Lua 5.4.6의 tarball은 압축 상태에서 355K, 압축 해제 상태에서 1.4M 다.\nLua is free # 루아는 MIT 라이센스 하에 배포되는 무료 오픈소스 소프트웨어다.\n상업적 목적을 포함한 모든 목적으로 무료로 사용할 수 있다.\nMy Thoughts on Why Using Lua # 당연히 공식 사이트에는 장점만 언급해두었겠지만, 우린 단점도 확인해봐야한다. 그리고 루아에도 단점이 있다.\n일단 근본적으로 인터프리터를 한 번 통해서 실행되기 때문에, 컴파일 언어에 비해 느리다.\n루아는 생각보다 많은 기능을 제공하지 않는다. 그래서 루아 그 자체로는 많은 것을 할 수 없다.\n파이썬을 생각해보면 라이브러리 천국이다, 하지만 루아는 모듈이나 라이브러리를 찾아다녀야 하고, 신뢰성이 부족한 라이브러리가 많다.\n그래서 루아를 제대로 사용하려면, 루아를 사용하는 어플리케이션에 맞는 모듈이나 라이브러리를 직접 만들어야 할 때가 많다고 한다.\n이러한 단점은 사실 지금 내가 하려는 것에 큰 문제는 아니다.\n루아 스크립트를 이용한 모딩 기능을 제공하는 것이 목표이기 때문이다.\n모딩 기능은 이미 만들어진 게임의 뼈대 위에 덮어지는 것이다.\n결국 이미 존재하는 인게임에 사용되는 함수나 이벤트에 바인딩 되어 사용될 것이다.\n루아를 사용해 처음부터 끝까지 게임을 만들 것은 아니기 때문에, 루아가 제공하는 기능이 부족하다고 해도 큰 문제가 되지 않는다.\n만약 부족하다 해도, 언리얼 엔진에서 제공하는 거의 대부분의 기능을 바인딩해서 사용할 수 있을 것이기 때문에, 큰 문제가 되지 않을 것이다.\n루아를 이용해 모든 로직을 작성하는 것은 아니기 때문에, 성능에 큰 영향을 미치지 않을 것이다. (아마도)\nConclusion # 꽤나 주저리주저리 길게 적었은 것 같지만, 일단 내가 생각하는 Introduction 은 여기까지다.\n시작하는 이유와 그에대한 내 생각과 감상을 적어보았다.\n그리고 루아에 대한 내용을 함께 적었다. 아직 루아를 잘 모르면서도 말이다.\n그래도 루아가 뭔지는 알고 시작해야 하기 때문에 약간의 루아와 관련 설명을 조사해서 적었다.\n나중에 공부하다 틀린 내용이 나오더라도, 내용을 추가하는 것이 아니라면 최대한 수정하지 않으려고 한다.\n그리고 만약 플러그인을 완성하게 된다면, 그 때 다시 돌아와 여기에 썼던 내용을 보고 내 생각을 다시 적어보겠다.\nReference # Lua.org Lua 5.4 Reference Manual Lua 5.4 Reference Manual (한국어) ","date":"2023-11-11","permalink":"/posts/luatonic/0-introduction/","section":"Posts","summary":"Introduction","title":"Lua Tonic #0 : Introduction"},{"content":"","date":"2023-11-10","permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++"},{"content":"","date":"2023-11-10","permalink":"/tags/condition-variable/","section":"Tags","summary":"","title":"Condition Variable"},{"content":"","date":"2023-11-10","permalink":"/series/game-server-development/","section":"Series","summary":"","title":"Game Server Development"},{"content":" Material # [C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버\nProblem of Event # Game Server Development #8 : Event \u0026lt;time datetime=\u0026#34;2023-10-19 00:00:00 \u0026amp;#43;0000 UTC\u0026#34;\u0026gt;2023-10-19\u0026lt;/time\u0026gt; Korean Post Programming C\u0026#43;\u0026#43; Server Thread Event 위 글에서 Windows 플렛폼에서 어떻게 Event 가 동작하는지에 대해서 간단히 알아봤었다.\n하지만, 이벤트에는 몇 가지 문제점이 있다.\nNon Standard # 이벤트는 Windows 플렛폼에서만 사용하는 비표준 내용이다.\nLinux 같은 다른 플렛폼에서는 Semaphore 같은 것을 사용해야 한다.\n이러한 표준적이지 않은 기능을 사용하면, 플렛폼에 종속적인 코드가 되어버린다.\nOverkilling by using Kernel Objects # 이벤트는 Kernel 에서 동작한다.\n이벤트를 사용하는 것은 잦은 Context Switch 를 발생시킨다.\nKernel Object 를 조작하는 명령을 수행하기 위해서는, User Mode 에서 Kernel Mode 로 전환해야하기 때문이다.\nCV 의 경우 User Mode 에서 동작하기 때문에, Context Switch 가 발생할 가능성이 적다.\n이러한 이벤트의 문제 상황을 해결하기 위해 C++11 부터 표준화된 Condition Variable 을 사용할 수 있다.\nCondition Variable # Condition Variable(이하 CV) 은 Event 와 비슷한 기능을 제공한다.\nCV 는 Wait 을 하다가 Notify 가 울리면, 신호를 수신한 CV 는 Wait 을 벗어나기 위한 Condition (조건) 을 확인한다.\n조건은 2가지 이다.\nLock 을 획득했는가? Condition 이 만족되었는가? (Predicate 를 사용하는 경우에만 체크한다) If Condition is Satisfied # Lock 을 획득했고, Condition 이 만족되었다면 대기 상태를 벗어나서 다음 줄로 진행한다.\nIf Condition is NOT Satisfied # Lock 을 획득하지 못한 경우, 다시 대기 상태로 돌아간다.\nLock 을 획득했으나, Condtion 이 만족되지 않았다면, Lock 을 풀고 대기 상태로 돌아간다.\nCV 는 Unique Lock 을 사용한다.\nWhy Using Unique Lock? # Game Server Development #3 : Lock \u0026lt;time datetime=\u0026#34;2023-08-12 00:00:00 \u0026amp;#43;0000 UTC\u0026#34;\u0026gt;2023-08-12\u0026lt;/time\u0026gt; Korean Post Programming C\u0026#43;\u0026#43; Server Thread Lock 위 글에서 알아봤듯, Unique Lock 을 사용하면, 명시적인 lock 함수 호출 이전까지, 락을 획득하지 않은 상태로 대기할 수 있다.\n또한, Scope 가 끝나기 전이라도 unlock 함수를 호출해 락을 해제할 수 있다.\n조건을 만족하지 못할 경우 락을 풀어주고 다시 대기해야 하기 때문에, Unique Lock 을 사용한다고 볼 수 있다.\nSpruious Wakeup # 이전 예제를 다시 생각해보자.\nConsumer 가 이벤트를 받아 Wait 에서 벗어났지만, Producer 가 찰나의 순간에 먼저 다시 락을 잡고, 데이터를 넣었을 수도 있다.\n만약 이러한 상태가 계속 지속된다면, Consumer 는 락을 획득하지 못해, Queue 에 접근할 수 없게 된다.\n또한, Queue 에 데이터가 지속적으로 누적되어 메모리가 부족해질 수도 있다.\n이러한 문제의 이유는 Event 와 Lock 이 개별적으로 동작하기 때문이다.\n조건이 만족되지 않은 상태에서 대기중인 스레드가 일어나 버리는 것을 Spuirous Wakeup (가짜 기상) 이라고 한다.\nEvent 나 Notify 등을 받거나 운영체제의 스케쥴러가 깨워서 다음 작업을 진행하려 스레드가 일어났지만, 원하던 조건이 만족되지 않은 상태를 의미한다.\n이러한 가짜 기상은 2 가지 정도의 문제로 바라볼 수 있다.\nIncorrect State Progression # 실제로 처리해야 할 데이터나 상태가 준비되지 않았음에도 불구하고 작업을 진행하려 시도할 수 있다.\n이러한 동작은 데이터 손상이나 논리적 오류를 초래할 수도 있다.\nWasting System Resources # 스레드가 필요 없이 깨어나 작업을 시도하면, 시스템 리소스가 낭비될 수 있다.\n그러므로 최대한 Spuirous Wakeup 을 방지할 수 있는 로직을 작성해야 한다.\n대부분은 Predicate 와 같은 조건을 통과하는지 체크하는 것으로 해결할 수 있다.\nCondition Variable Functions # CV 를 사용하기 위해서는 mutex 헤더를 추가해야 한다.\n만약 좀 더 일반화된 상황에서 직접 Lock 을 구현해 사용하는 경우라면 std::condition_variable_any 를 사용하기 위해 condition_variable 헤더를 추가해 사용하면 된다.\nCV 가 표준으로 제공하는 함수들은 다음과 같다.\nWaiting # 대기를 위해 사용되는 함수 시리즈이다.\nwait # wait 은 그냥 대기하는 버전과 Predicate 를 사용하는 버전이 있다.\nvoid wait( std::unique_lock\u0026lt;std::mutex\u0026gt;\u0026amp; lock ); template\u0026lt; class Predicate \u0026gt; void wait( std::unique_lock\u0026lt;std::mutex\u0026gt;\u0026amp; lock, Predicate pred ); wait_for # CV 가 깨어나거나, 지정된 시간 (Timeout Duration) 이 지나면 현재 스레드를 대기시킨다.\nwait_until # CV 가 깨어나거나, 지정된 시점 (Time Point) 에 도달할 때까지 현재 스레드를 대기시킨다.\nNotifing # 대기 상태를 깨우는(Wake Up) 방법에 대한 함수 시리즈이다.\nnotify_one # CV 가 대기 중인 스레드 중 하나를 깨운다.\nnotify_all # CV 가 대기 중인 모든 스레드를 깨운다.\nCondition Variable Example # CV 를 사용하여 위에서 작성했던 Event 의 예제 코드를 다시 작성해보자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;queue\u0026gt; std::mutex m; std::queue\u0026lt;int\u0026gt; q; std::condition_variable cv; void Producer() { while(true) { { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(m); q.push(100); } cv.notify_one(); } } void Consumer() { while(true) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(m); //Condition Variable 이 조건을 만족할 때 까지 대기한다. //1. lock 을 획득하려고 시도한다. //2. q 가 비어있지 않은지 체크한다. //둘 다 만족해야 wait 을 벗어날 수 있다. //조건을 만족하지 못한다면, lock 을 풀고 다시 대기한다. cv.wait(lock, []() { return !q.empty(); }); int data = q.front(); q.pop(); //Lock 을 잡고, 콘솔 출력을 하는 것은 좋은 습관은 아님. std::cout\u0026lt;\u0026lt;data\u0026lt;\u0026lt;std::endl; } } int main() { std::thread t1(Producer); std::thread t2(Consumer); t1.join(); t2.join(); return 0; } Conclusion # 표준으로 제공되는 Condition Variable 을 사용하면, 플렛폼에 종속적이지 않은 코드를 작성할 수 있다.\nEvent 와 Lock 이 개별적으로 동작하는 문제점을 해결할 수 있다.\nSpuirous Wakeup 을 방지하기 위해 Predicate 조건을 정의하는 등의 추가적인 작업이 필요하다.\nReference # Condition Variable Spurious Wakeup ","date":"2023-11-10","permalink":"/posts/game-server-development/9-condition-variable/","section":"Posts","summary":"Event","title":"Game Server Development #9 : Condition Variable"},{"content":"","date":"2023-11-10","permalink":"/tags/server/","section":"Tags","summary":"","title":"Server"},{"content":"","date":"2023-11-10","permalink":"/tags/thread/","section":"Tags","summary":"","title":"Thread"},{"content":"","date":"2023-10-19","permalink":"/tags/event/","section":"Tags","summary":"","title":"Event"},{"content":" Material # [C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버\nEvent # Event 는 운영 체제의 스레드 동기화 매커니즘 중 하나로, 특정 이벤트가 발생했는지 여부에 따라 하나 이상의 스레드가 대기하거나 실행을 계속할 수 있도록 하는 신호를 제공한다.\n주로 비동기 작업에서 상태 변화나 특정 조건의 발생을 스레드에 알리는 데 사용된다.\n이벤트 관리를 위해 운영체제에서 Kernel Object 를 생성하며, 커널 오브젝트는 다른 프로세스에서도 접근할 수 있다.\nEvent State # 이벤트는 Signaled 와 Non-Signaled 상태를 가진다.\nSignaled 상태는 이벤트가 발생했음을 의미한다.\nNon-Signaled 상태는 이벤트가 발생하지 않았음을 의미한다.\nEvent Reset Type # Manual Reset 은 이벤트가 Signaled 상태가 되면, Reset 을 따로 호출하기 전까지 Signaled 상태를 유지한다.\nAuto Reset 은 이벤트가 Signaled 상태가 되면, 따로 Reset 을 호출하지 않아도 곧바로 Non-Signaled 상태로 바뀐다.\nEvent Functions # Event 사용을 위해 Windows 운영체제에서는 다음과 같은 함수를 제공한다.\nCreateEvent # Event 를 생성할 때, 사용하는 함수이다.\nCreateEvent 함수의 원형은 다음과 같다.\nHANDLE CreateEvent( LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCTSTR lpName ); lpEventAttributes : 이벤트의 보안 속성을 설정한다. NULL 을 입력하면 기본값으로 설정된다.\nbManualReset : Manual Reset 과 Auto Reset 을 선택할 수 있다.\nbInitialState : 이벤트의 초기 상태를 설정한다. TRUE 를 입력하면 Signaled 상태로, FALSE 를 입력하면 Non-Signaled 상태로 시작한다.\nlpName : 이벤트의 이름을 설정한다. NULL 을 입력하면 이름이 없는 이벤트 를 생성한다.\nreturn : 이벤트를 생성하면 이벤트의 HANDLE 을 반환한다. 이벤트 생성에 실패하면 NULL 을 반환한다.\nSetEvent # 이벤트를 Signaled 상태로 만들 때, 사용하는 함수이다.\nResetEvent # 이벤트를 Non-Signaled 상태로 만들 때, 사용하는 함수이다.\nWaitForSingleObject # 이벤트가 Signaled 상태가 될 때까지 대기하는 함수이다.\nWaitForSingleObject 함수의 원형은 다음과 같다.\nDWORD WaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds ); hHandle : Wait 할 이벤트의 HANDLE 을 입력한다.\ndwMilliseconds : Wait 할 시간을 입력한다. INFINITE 를 입력하면 무한정 대기한다.\nreturn : 이벤트가 Signaled 상태가 되면 WAIT_OBJECT_0 을 반환한다. Wait 시간이 지나면 WAIT_TIMEOUT 을 반환한다.\nWaitForMultipleObjects # 여러 개의 이벤트가 Signaled 상태가 될 때까지 대기하는 함수이다.\nWaitForMultipleObjects 함수의 원형은 다음과 같다.\nDWORD WaitForMultipleObjects( DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds ); nCount : Wait 할 이벤트의 개수를 입력한다.\nlpHandles : Wait 할 이벤트의 HANDLE 을 입력한다.\nbWaitAll : Wait 할 이벤트가 모두 Signaled 상태가 될 때까지 대기할지 여부를 입력한다. TRUE 를 입력하면 모두 Signaled 상태가 될 때까지 대기하고, FALSE 를 입력하면 하나라도 Signaled 상태가 되면 대기를 종료한다.\ndwMilliseconds : Wait 할 시간을 입력한다. INFINITE 를 입력하면 무한정 대기한다.\nreturn : Wait 할 이벤트가 Signaled 상태가 되면 WAIT_OBJECT_0 을 반환한다. Wait 시간이 지나면 WAIT_TIMEOUT 을 반환한다.\nBehavior of WaitForSingleObject Based on Reset Type # WaitForSingleObject 는 `SetEvent`` 가 호출되는 순간 대기중인 모든 상태를 깨울까?\n코드를 통해 테스트 해보자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;Windows.h\u0026gt; HANDLE g_handle; void Signal() { ::SetEvent(g_handle); std::cout \u0026lt;\u0026lt; \u0026#34;Signaled!\u0026#34; \u0026lt;\u0026lt; std::endl; } void Receiver1() { ::WaitForSingleObject(g_handle, INFINITE); std::cout \u0026lt;\u0026lt; \u0026#34;Receive #1\u0026#34; \u0026lt;\u0026lt; std::endl; } void Receiver2() { ::WaitForSingleObject(g_handle, INFINITE); std::cout \u0026lt;\u0026lt; \u0026#34;Receive #2\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { //Manual Reset 을 FALSE 로 설정하여, Auto Reset 인 경우. g_handle = ::CreateEvent(NULL, FALSE, FALSE, NULL); std::thread t1(Signal); std::thread t2(Receiver1); std::thread t3(Receiver2); t1.join(); t2.join(); t3.join(); ::CloseHandle(g_handle); return 0; } 위 코드의 결과는 다음과 같다.\nSignaled! Receive #2 여기서 더 이상 실행되지 않는다.\n이유는 Receiver1 의 WaitForSingleObject 가 통과되지 못하였기 때문이다.\n그러므로, t2 스레드가 대기 상태로 들어가며, t2.join 또한 통과되지 못하기 때문이다.\nWaitForSingleObject 는 Auto Reset 하게 된다면, Signaled 이후 즉시 Non-Signaled 상태로 변경되기 때문에 다른 대기중인 스레드를 깨워주지 않는다.\n그렇다면 즉시 Non-Signaled 상태로 가지 않도록 Manual Reset 으로 하게 된다면 모두 울릴까?\n테스트 해보자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;Windows.h\u0026gt; HANDLE g_handle; void Signal() { ::SetEvent(g_handle); std::cout \u0026lt;\u0026lt; \u0026#34;Signaled!\u0026#34; \u0026lt;\u0026lt; std::endl; } void Receiver1() { ::WaitForSingleObject(g_handle, INFINITE); std::cout \u0026lt;\u0026lt; \u0026#34;Receive #1\u0026#34; \u0026lt;\u0026lt; std::endl; } void Receiver2() { ::WaitForSingleObject(g_handle, INFINITE); std::cout \u0026lt;\u0026lt; \u0026#34;Receive #2\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { g_handle = ::CreateEvent(NULL, TRUE, FALSE, NULL); std::thread t1(Signal); std::thread t2(Receiver1); std::thread t3(Receiver2); t1.join(); t2.join(); t3.join(); ::CloseHandle(g_handle); return 0; } bManualReset 을 TRUE 로 설정했다.\n결과는 다음과 같다.\nSignaled! Receive #1 Receive #2 모두 호출되었다.\n다만, 이 경우 ResetEvent 를 호출하지 않았으므로, 여전히 g_handle 에 대한 Event 는 Signaled 상태로 유지된다.\nProblem Example # 아래 코드는 Producer 스레드가 Consumer 스레드에게 데이터를 전달하는 코드이다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;queue\u0026gt; std::mutex m; std::queue\u0026lt;int\u0026gt; q; void Producer() { while(true) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(m); q.push(100); } std::this_thread::sleep_for(100ms); } void Consumer() { while(true) { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(m); if(!q.empty()) { int data = q.front(); q.pop(); //Lock 을 잡고, 콘솔 출력을 하는 것은 좋은 습관은 아님. std::cout\u0026lt;\u0026lt;data\u0026lt;\u0026lt;std::endl; } } } int main() { std::thread t1(Producer); std::thread t2(Consumer); t1.join(); t2.join(); return 0; } 만약 Producer 스레드에 데이터가 들어가는 시간이 100ms 가 아니라, 1 시간 이라면 어떨까?\nConsumer 스레드는 Producer 스레드가 데이터를 전달할 때까지 while 문을 돌며 계속 대기해야 한다.\n이처럼 오래 걸릴 것이 예상되는 작업에 SpinLock 을 사용하는 것은 CPU 자원을 낭비하게 된다.\nSolution by using Event # Event 를 사용하면 이러한 문제를 다음과 같이 해결할 수 있다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;Windows.h\u0026gt; std::mutex m; std::queue\u0026lt;int\u0026gt; q; HANDLE handle; void Producer() { while(true) { { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(m); q.push(100); } ::SetEvent(handle); std::this_thread::sleep_for(100ms); } } void Consumer() { while(true) { //Signaled 상태가 될 때까지 무한정 대기한다. ::WaitForSingleObject(handle, INFINITE); //만약 Event 가 Manual Reset 으로 생성되었다면, Non-Signaled 상태로 바꿔준다. //::ResetEvent(handle); std::unique_lock\u0026lt;std::mutex\u0026gt; lock(m); if(!q.empty()) { int data = q.front(); q.pop(); //Lock 을 잡고, 콘솔 출력을 하는 것은 좋은 습관은 아님. std::cout\u0026lt;\u0026lt;data\u0026lt;\u0026lt;std::endl; } } } int main() { //Event 를 생성한다. //bManualReset 을 FALSE 로 설정했다. Auto Reset 기능을 사용한다. //Initial State 를 FALSE 로 설정했다. Non-Signaled 상태로 시작한다. handle = ::CreateEvent(NULL, FALSE, FALSE, NULL); std::thread t1(Producer); std::thread t2(Consumer); t1.join(); t2.join(); //Event 를 사용하기 위해 발급한 Handle 을 닫는다. ::CloseHandle(handle); return 0; } 이처럼 Event 를 사용하면 SpinLock 을 사용하는 것보다 효율적으로 CPU 를 사용할 수 있다.\nConclusion # 이벤트는 특정 이벤트가 발생했음을 알리는 신호를 운영체제가 제공하는 스레드 동기화 매커니즘이다.\n이벤트는 Signaled 와 Non-Signaled 상태를 가지며, Manual Reset 과 Auto Reset 으로 나뉜다.\n오래 걸릴 것이 예상되는 작업에는 SpinLock 을 사용하는 것보다 Event 를 사용하는 것이 효율적으로 CPU 를 사용할 수 있게 해준다.\n이벤트를 사용할 때는 Wait 할 때마다 이벤트를 Reset 해주어야 한다는 점을 유의해야 한다.\nEvent 를 사용할 때는 SpinLock 을 사용하는 것보다 Context Switch 가 발생할 가능성이 높으므로 주의해야 한다.\n유저 모드에서 Kernel Object 에 접근하는 것은 Context Switch 를 발생시키기 때문이다.\n","date":"2023-10-19","permalink":"/posts/game-server-development/8-event/","section":"Posts","summary":"Event","title":"Game Server Development #8 : Event"},{"content":" Material # [C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버\nIntroduction # 이전 글에서 while 문 내부에서 CAS 체크를 통해 SpinLock 을 구현하는 방법에 대해서 알아봤었다.\nGame Server Development #6 : Spin Lock \u0026lt;time datetime=\u0026#34;2023-09-08 00:00:00 \u0026amp;#43;0000 UTC\u0026#34;\u0026gt;2023-09-08\u0026lt;/time\u0026gt; Korean Post Programming C\u0026#43;\u0026#43; Server Thread Lock while 문을 통해 지속적으로 락을 획득하려고 시도하는 방식에는 CPU 자원을 낭비하는 문제가 있다.\n이를 어느정도 막기 위해 Sleep 을 사용하여 현재 스레드의 동작을 잠시 멈추게 할 수 있다.\n멈춘 스레드는 일정 시간이 지나면 다시 동작하게 되며, 멈춰있는 동안 CPU 를 사용하지 않기 때문에 CPU 자원을 낭비하지 않게 된다.\nSleep # sleep 은 특정 쓰레드 또는 프로세스를 지정된 시간 동안 말 그대로 잠재운다. (일시적으로 중단한다)\n호출되면, 해당 쓰레드는 설정된 시간 동안 일을 중단하고, 그 동안 CPU는 다른 스레드의 작업을 수행한다.\n주로 정확한 시간 동안 쓰레드를 중지하기 위해 사용된다.\nC++ 11 부터 std::this_thread::sleep_for 를 통해 스레드를 잠시 멈출 수 있다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Start\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); std::cout \u0026lt;\u0026lt; \u0026#34;End\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 위 코드는 Start 를 출력하고, 1초 동안 멈춘 뒤 End 를 출력한다.\nYield # yield 는 현재 실행 중인 쓰레드가 실행을 양보하고, 동일한 우선순위를 가진 다른 쓰레드에게 실행 기회를 제공한다.\n호출할 경우, 현재 쓰레드는 준비 상태로 전환되고, 스케줄러는 동일한 우선순위의 다른 쓰레드를 실행한다.\n만약 동일한 우선순위의 쓰레드가 없다면, yield 를 호출한 쓰레드는 계속해서 실행을 이어간다.\nC++ 11 부터 std::this_thread::yield 를 통해 현재 스레드를 일단 멈추고, 다른 스레드에게 CPU 를 양보할 수 있다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;chrono\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Start\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::yield(); std::cout \u0026lt;\u0026lt; \u0026#34;End\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 위 코드는 Start 를 출력하고, 다른 스레드에게 CPU 를 양보한 뒤, 다시 실행하게 된다면 End 를 출력한다.\nTime Slice # Time Slice 는 CPU 가 스레드에게 할당하는 시간을 의미한다.\n스레드는 Time Slice 를 모두 소진하면, 다른 스레드에게 CPU 를 양보하게 된다.\nTime Slice 는 운영체제에 의해 관리되며, Time Slice 가 끝나기 전에 스레드가 끝나게 되면, 다른 스레드에게 CPU 를 양보하지 않고 계속해서 CPU 를 사용하게 된다.\nSpint Lock (Sleep) # 이전에 작성했던 코드에서 SpinLock 을 사용할 때, while 문 내부에서 Sleep 을 사용하여 CPU 자원을 낭비하지 않도록 할 수 있다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;atomic\u0026gt; #include \u0026lt;chrono\u0026gt; class SpinLock { public: void lock() { bool expected = false; bool desired = true; // CAS (Compare-And-Swap) while (_locked.compare_exchange_strong(expected, desired) == false) { expected = false; // 1. chrono 라이브러리를 사용하여 100ms 동안 스레드를 멈춘다. std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 2. 아래처럼 ms 를 사용하여 100ms 동안 스레드를 멈출수도 있다. 결론적으로 위와 같은 코드다. std::this_thread::sleep_for(100ms); // 3. yield 를 사용하여 현재 스레드를 일단 멈추고 다음 스케쥴을 기다릴 수 있다. (언제 다시 돌아올지 모름) std::this_thread::yield(); } } void unlock() { _locked.store(false); } private: std::atomic\u0026lt;bool\u0026gt; _locked = false; }; int sum = 0; SpinLock spinLock; void Add() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { std::lock_guard\u0026lt;SpinLock\u0026gt; guard(spinLock); sum++; } } void Sub() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { std::lock_guard\u0026lt;SpinLock\u0026gt; guard(spinLock); sum--; } } int main() { std::thread t1(Add); std::thread t2(Sub); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } ","date":"2023-10-08","permalink":"/posts/game-server-development/7-sleep/","section":"Posts","summary":"Sleep","title":"Game Server Development #7 : Sleep"},{"content":"","date":"2023-10-08","permalink":"/tags/lock/","section":"Tags","summary":"","title":"Lock"},{"content":" Material # [C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버\nIntroduction # 이전 글에서 락의 구현 방식에 대해 설명하며, 스핀 락에 대한 설명도 진행 했었다.\nGame Server Development #5 : Lock Implementation Theory \u0026lt;time datetime=\u0026#34;2023-09-04 00:00:00 \u0026amp;#43;0000 UTC\u0026#34;\u0026gt;2023-09-04\u0026lt;/time\u0026gt; Korean Post Programming C\u0026#43;\u0026#43; Server Thread Lock Spinlock 은 이름에서 알 수 있듯이, 자원에 접근할 수 있을 때까지 계속해서 Spin(Loop) 하는 락이다.\nSpinlock 은 굉장히 빠르게 작동하므로, 락을 획득하고 해제하는 작업이 매우 빠르게 이루어질 것이라고 예상되는 상황에서 효율적이다.\n반대로 락을 획득하는 데 오랜 시간이 걸리는 경우에는 CPU 자원을 불필요하게 낭비하게 된다.\n락을 획득할 때 까지 존버 하는 메타라고 보면 된다.\nScenario # 아래의 코드를 보자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; int sum = 0; void Add() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { sum++; } } void Sub() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { sum--; } } int main() { std::thread t1(Add); std::thread t2(Sub); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 위 코드는 결과적으로 0 을 출력하지 못한다.\nsum 이라는 공유 자원에 대한 동기화를 맞춰주지 않았기 때문이다.\n근본적인 내용은 아래 Atomic 글에서 설명했었으니, 기억이 안난다면 한 번 다시 보면 좋을 것이다.\nGame Server Development #2 : Race Condtion, Atomic \u0026lt;time datetime=\u0026#34;2023-08-11 00:00:00 \u0026amp;#43;0000 UTC\u0026#34;\u0026gt;2023-08-11\u0026lt;/time\u0026gt; Korean Post Programming C\u0026#43;\u0026#43; Server Thread Atomic 그럼 이제 위 코드의 결과로 0 이 나올 수 있도록, 스핀락을 직접 구현하고 사용하여 동기화를 맞춰보자.\nSpin Lock Implementation for Dummies # 스핀락은 다시 쉽게 설명하면 뺑뺑이를 돌면서 계속해서 락을 획득하려고 시도하는 방식이다.\n아무런 배경 지식 없이, 스핀락에 대해 아는 것은 위에 내용이 전부라고 생각해보자.\n그 상태에서는 일단 아래와 같이 스핀락을 구현할 수 있을 것이다.\nclass SpinLock { public: void lock() { while (_locked) { } _locked = true; } void unlock() { _locked = false; } private: bool _locked = false; }; lock 함수에서는 _locked 가 false 일 때까지 계속해서 뺑뺑이를 돌면서 기다린다.\n_locked 가 false 가 되면, _locked 를 true 로 바꿔주며, 락을 획득한다.\nunlock 함수에서는 _locked 를 false 로 바꿔주며, 락을 해제한다.\n이렇게 구현하면, 위의 코드에서 sum 에 대한 동기화를 맞춰줄 수 있을까?\n코드로 확인해보자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; class SpinLock { public: void lock() { while (_locked) { } _locked = true; } void unlock() { _locked = false; } private: bool _locked = false; }; int sum = 0; SpinLock spinLock; void Add() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { std::lock_guard\u0026lt;SpinLock\u0026gt; guard(spinLock); sum++; } } void Sub() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { std::lock_guard\u0026lt;SpinLock\u0026gt; guard(spinLock); sum--; } } int main() { std::thread t1(Add); std::thread t2(Sub); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 위 코드의 실행 결과는 1843 이었다. (매번 실행할 때마다 결과가 다르다.)\n결국 현재의 SpinLock 구현은 sum 에 대한 동기화를 맞춰주지 못했다는 것을 알 수 있다.\n일단은 위 코드는 여러가지 문제가 있는데 그 중 하나는 컴파일러 최적화 이다.\nC++ Volatile # C++ 에서는 volatile 이라는 키워드가 있다.\n컴파일러에게 volatile 로 선언된 이 변수는 최적화 하지 말라고 알려주는 역할을 한다.\n주의! C++ 에서의 volatile 은 C#, Java 와 같은 언어에서의 volatile 과 다르다. ( 관련 문서) 예를 들면 아래와 같은 간단한 코드를 보자.\nint main() { int num = 0; num = 1; num = 2; num = 3; num = 4; return 0; } 이 코드는 결론적으로 num 의 값이 4 가 될 것이다.\n하지만, 중간에 1, 2, 3 을 거치는 과정이 존재한다.\n이 부분들은 컴파일러에 의해 최적화 과정에서 제거될 수 있다.\n디스어셈블리를 확인해보면 다음과 같다.\nint main() { 00007FF727F31000 sub rsp,28h int num = 0; num = 1; num = 2; num = 3; num = 4; std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; std::endl; 00007FF727F31004 mov rcx,qword ptr [__imp_std::cout (07FF727F320A8h)] 00007FF727F3100B mov edx,4 ... } 디스어셈블리로 확인해보니, num 에 곧바로 4 를 대입 해버린다.\n00007FF727F31004 mov rcx,qword ptr [__imp_std::cout (07FF727F320A8h)] 00007FF727F3100B mov edx,4 이처럼 컴파일러는 최적화 과정에서, 필요 없다고 판단되는 num 에 대한 중간 과정을 제거할 수 있다.\n하지만, 어떠한 이유로 이러한 최적화를 원치 않는 경우도 있을 것이다.\n그때 volatile 키워드를 사용할 수 있다.\nnum 에 volatile 을 붙여 다시 확인해보자.\nint main() { volatile int num = 0; num = 1; num = 2; num = 3; num = 4; return 0; } 위 코드의 디스어셈블리 결과는 다음과 같다.\nint main() { 00007FF633B81000 sub rsp,28h volatile int num = 0; 00007FF633B81004 mov dword ptr [rsp+30h],0 num = 1; 00007FF633B8100C mov dword ptr [num],1 num = 2; 00007FF633B81014 mov dword ptr [num],2 num = 3; 00007FF633B8101C mov dword ptr [num],3 num = 4; 00007FF633B81024 mov dword ptr [num],4 std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; std::endl; ... } num 에 volatile 을 붙여주니, 컴파일러가 최적화를 하지 않고, 사실상 쓸대없는 중간 과정을 그대로 실행하게 되었다.\n비슷한 맥락으로 SpinLock 클래스에서 잠김 여부를 확인하기 위해 사용한 _locked 변수 또한, 여러 스레드에서 확인 및 수정이 일어나는 상황이 있을 것이다.\n하지만 volatile 키워드가 없다면, 최적화를 통해 매번 수행되어야 하는 상태 체크가 무시될 수도 있다.\n그렇기 때문에, _locked 변수에 volatile 을 붙여주어 컴파일러가 최적화를 하지 않도록 해주어야 한다.\n하지만, 지금 상황에서는 그것 만이 문제는 아니기 때문에, 일단 교양 차원에서 여기까지만 알아두도록 하자.\nProblems # 현재의 SpinLock 은 여러 문제가 있지만, 가장 중요한 문제로 원자성이 보장되지 않는다는 점이 있다.\n_locked 변수에 대한 접근은 원자적으로 이루어져야 한다.\n2개 이상의 스레드가 _locked 를 false 로 보고, 동시에 _locked 를 true 로 바꾸려고 시도한다면, 두 스레드 모두 _locked 를 true 로 바꾸게 될 것이다.\n이렇게 되면, 락을 제대로 획득한 것이 아닌 상태에서 락을 획득한 것으로 인식하게 되어, 문제가 발생할 수 있다.\n예를 들어보자면 화장실에 두명이 달려가서 동시에 문을 잠궈버려 두 명이 큰일을 보는\u0026hellip;?! 상황과 같다.\n이러한 불상사는 일어나면 안된다. 이제 문제를 해결해보자.\nCompare And Swap # Compare And Swap (CAS) 연산은 원래의 값과 비교하여 값이 같으면 새 값을 저장한다.\n동시성 환경에서 변경이 필요한 값의 Memory\n최종적으로 변화하길 원하는 값인 Desired\n변화를 만들기 위한 조건으로 기대하고 있는 값인 Expected\n위 3 가지 요소들을 가지고 비교와 변경을 한 번에 진행한다.\n또한, 원래의 값(Memory) 이 다른 스레드에 의해 도중에 변경되면 연산은 실패하고 재시도 된다.\nCAS 를 C++ 에서 사용할 때는 다음과 같은 함수가 사용된다.\ntemplate\u0026lt; class T \u0026gt; bool atomic_compare_exchange_strong( std::atomic\u0026lt;T\u0026gt;* obj, typename std::atomic\u0026lt;T\u0026gt;::value_type* expected, typename std::atomic\u0026lt;T\u0026gt;::value_type desired ) noexcept; std::atomic_compare_exchange_strong(Memory, Expected, Desired); //weak 도 있다. 위의 CAS 를 의사 코드로 표현해보면 다음과 같다.\nif (Memory == Expected) { Expected = Memory; Memory = Desired; return true; } else { Expected = Memory; return false; } Spin Lock Implementation # 이제 SpinLock 을 CAS 를 이용하여 구현해보자.\n#include \u0026lt;atomic\u0026gt; class SpinLock { public: void lock() { bool expected = false; bool desired = true; // CAS (Compare-And-Swap) while (_locked.compare_exchange_strong(expected, desired) == false) { expected = false; } } void unlock() { _locked.store(false); } private: std::atomic\u0026lt;bool\u0026gt; _locked = false; }; 가장 먼저 _locked 를 std::atomic\u0026lt;bool\u0026gt; 로 선언해주었다.\nlock 함수에서 _locked 가 false 가 되기를 예상하면서(Expected) while 문을 돌며 계속 확인한다. (Spin 한다.)\n예상대로 _locked 가 false 가 되면, 원하던 대로(Desired) _locked 를 true 로 바꿔주며, 락을 획득한다.\n하지만, _locked 가 true 인 상태라면, CAS 의 행동 방식대로 expected 에 현재의 _locked 값인 true 가 저장된다.\n그 상태로 다음 체크에 들어가게 되면, expected 는 true 가 되어있기 때문에, while 문을 빠져나오게 된다.\n이러한 문제를 막기 위해 시도를 실패했을 때, expected 를 다시 false 로 바꿔준다.\n이처럼 CAS 를 이용하여 원자적으로 _locked 를 변경해 동시에 여러 스레드가 _locked 를 true 로 바꾸는 문제를 해결할 수 있게 되었다.\n아래의 코드로 확인해볼 수 있다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;atomic\u0026gt; class SpinLock { public: void lock() { bool expected = false; bool desired = true; // CAS (Compare-And-Swap) while (_locked.compare_exchange_strong(expected, desired) == false) { expected = false; } } void unlock() { _locked.store(false); } private: std::atomic\u0026lt;bool\u0026gt; _locked = false; }; int sum = 0; SpinLock spinLock; void Add() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { std::lock_guard\u0026lt;SpinLock\u0026gt; guard(spinLock); sum++; } } void Sub() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { std::lock_guard\u0026lt;SpinLock\u0026gt; guard(spinLock); sum--; } } int main() { std::thread t1(Add); std::thread t2(Sub); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 실행 결과는 몇번을 실행하던지 0 이 나왔다.\n동기화가 잘 이루어졌음을 확인할 수 있다.\n","date":"2023-09-08","permalink":"/posts/game-server-development/6-spinlock/","section":"Posts","summary":"Spin Lock","title":"Game Server Development #6 : Spin Lock"},{"content":" Material # [C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버\nSpin Lock # Spinlock 은 이름에서 알 수 있듯이, 자원에 접근할 수 있을 때까지 계속해서 Spin(Loop) 하는 락이다.\nSpinlock은 굉장히 빠르게 작동하므로, 락을 획득하고 해제하는 작업이 매우 빠르게 이루어질 것이라고 예상되는 상황에서 효율적이다.\n반대로 락을 획득하는 데 오랜 시간이 걸리는 경우에는 CPU 자원을 불필요하게 낭비하게 된다.\n락을 획득할 때 까지 존버 하는 메타라고 보면 된다.\nBusy-Waiting # Spinlock은 락을 얻을 수 있을 때까지 계속 CPU를 사용한다. 그래서 CPU 시간을 낭비할 수 있다.\nPriority Inversion # 높은 우선 순위의 스레드가 낮은 우선 순위의 스레드를 기다리게 되면 효율성이 떨어질 수 있다.\nBackoff Lock # 백오프(Backoff) 는 한 발 물러선다는 뜻이다.\n랜덤하게나 일정 시간마다 락의 상태를 확인하는 전략을 이용하는 락이다.\nSpinlock 의 문제점인 Busy Waiting 문제를 완화하기 위해 사용한다.\n락을 얻지 못할 경우 잠시 대기하고, 그 대기 시간을 최소, 최대 기간 범위 내에서 랜덤하게 증가시키는 방식이다.\n이렇게 하면 여러 스레드가 동시에 락을 획득하려고 할 때 발생하는 contention (경쟁 상태) 을 줄일 수 있다.\n백오프 전략은 시스템의 전체 성능에 도움을 줄 수 있지만, 어떤 상황에서는 락을 획득하는데 필요한 시간이 늘어나게 할 수도 있다.\n실제 시스템에서 어떻게 동작하는지 테스트하고 적절한 최소, 최대 값을 선택하는 것이 중요하다.\nEvent (Notify) Lock # 특정 락이 풀리면, 그 락을 잡기 위해 대기중인 스레드들에게 이벤트를 전달해서 깨우는 방식도 있다.\n락 풀리면 너(운영체제) 가 알려줘 하고 자러가는 갑질 메타 라고 볼 수 있다.\nContext Switch # 컨텍스트 스위칭은 운영체제의 스케줄러가 CPU를 다른 프로세스 또는 스레드에 할당하기 위해 현재 실행 중인 프로세스 또는 스레드의 상태를 저장하고 다른 프로세스 또는 스레드의 상태를 복원하는 과정을 의미한다.\n이렇게 함으로써, 단일 CPU에서 여러 프로세스 또는 스레드가 동시에 실행되는 것처럼 보이게 된다.\n이 과정은 당연하게 느껴지면서도, 신경써야 할 점들이 있다.\nOverhead # 컨텍스트 스위칭은 CPU가 다른 작업을 수행할 수 있는 시간을 소모한다.\n특히 고성능이 필요한 애플리케이션에서 잦은 컨텍스트 스위칭은 문제가 될 수 있다.\nCache Invalidation # 프로세스 또는 스레드가 변경될 때, CPU 캐시에 있던 데이터가 무효화될 수 있다.\nCache Miss 가 빈번하게 발생하면 성능이 저하될 수 있다.\nUser \u0026lt;-\u0026gt; Kernel Mode # 유저 모드 (User Mode)와 커널 모드 (Kernel Mode)는 운영체제와 프로세스가 CPU에서 명령을 실행할 때의 두 가지 주요 실행 모드다.\n이 두 모드는 시스템의 안정성과 보안을 보장하는 데 중요한 역할을 한다.\n컴퓨터 시스템의 안정성과 보안을 위해 일반적인 애플리케이션들이 직접적으로 하드웨어에 액세스하는 것을 제한하기 때문이다.\n이 구분을 통해 잘못된 애플리케이션 코드나 악의적인 코드가 전체 시스템을 손상시키는 것을 방지한다.\n시스템 호출을 통해 유저 모드에서 커널 모드로 전환되는 것은 오버헤드가 있다.\n유저 프로세스와 커널 간의 정보를 저장하고 복원해야 하기 때문이다.\n빈번한 모드 전환이 성능에 부정적인 영향을 줄 수 있다.\nUser Mode # 프로세스가 자신의 메모리 공간에서 실행되는 모드다.\n유저 모드에서 실행되는 프로세스는 직접적으로 하드웨어 자원에 액세스할 수 없다.\n제한된 명령만 실행할 수 있으며, 보다 높은 권한이 필요한 작업을 수행하려면 커널 모드로 전환되어야 한다.\n예를 들어, 파일을 읽거나 쓰려면 운영체제에 요청을 하고, 이 요청은 커널 모드에서 처리된다.\nSpinlock 은 유저 모드에서 계속 실행시켜둘 수 있지만, Backoff 나 Notify 를 이용할 경우, 커널 모드로 전환하여 작업하여야 한다.\nKernel Mode # 운영체제의 핵심 부분이 실행되는 모드다.\n커널 모드에서는 모든 CPU 명령과 하드웨어 자원에 접근할 수 있다.\n유저 모드에서는 수행할 수 없는 시스템 호출 (예: I/O 요청, 프로세스 관리, 메모리 관리, 스레드 관리 등)을 수행할 때 커널 모드로 전환된다.\n이 모드에서 오류가 발생하면 시스템 전체에 영향을 미칠 수 있다.\n","date":"2023-09-04","permalink":"/posts/game-server-development/5-lock-implementation-theory/","section":"Posts","summary":"Dead Lock","title":"Game Server Development #5 : Lock Implementation Theory"},{"content":" Material # [C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버\n아래 글의 #Dead-Lock 섹션에 기본적인 문제를 설명해 두었었다. 먼저 읽어본다면 지금 글을 이해하는데 도움이 될 것이다.\nGame Server Development #3 : Lock \u0026lt;time datetime=\u0026#34;2023-08-12 00:00:00 \u0026amp;#43;0000 UTC\u0026#34;\u0026gt;2023-08-12\u0026lt;/time\u0026gt; Korean Post Programming C\u0026#43;\u0026#43; Server Thread Lock 4 Necessary Conditions for Dead Lock # Dead Lock 이 발생하려면 다음의 4 가지 조건이 동시에 만족되어야 한다.\n상호 배제 (Mutual Exclusion) # 한 번에 한 프로세스만 공유 자원을 사용할 수 있다.\n점유 및 대기 (Hold and Wait) # 프로세스가 최소한 하나의 자원을 점유하고 있으면서, 다른 프로세스에 의해 점유 중인 자원을 추가로 기다린다.\n비선점 (No Preemption) # 자원을 점유한 프로세스는 그 자원을 스스로만 방출할 수 있다.\n환형 대기 (Circular Wait) # 두 개 이상의 프로세스나 스레드가 서로를 기다리는 사이클이 형성한다.\nProblem Example # 아직 데드락을 탐지하는 방법은 배우지 않았고, 추후 작성할 Dead Lock Detection 글에서 문제 해결 방법을 이어 설명할 예정이다.\n이번 글에서는 데드락이 일어나는 또 다른 경우와 그 해결법에 대해 설명한다.\nAccount 라는 정보를 관린하는 Account Manager 클래스가 존재하고, User 라는 정보를 관리하는 User Manager 가 존재한다고 가정해보자.\n~Manager 들은 Singleton 으로 구현되어 있으며, MMORPG 게임의 유저와 계정 정보를 관리하는 클래스이다.\n코드로 작성해보면 다음과 같다.\nAccount Manager\nclass Account { //TEMP } class AccountManager { public: static AccountManager* Instance() { static AccountManager instance; return \u0026amp;instance; } Account* GetAccount(int32 id) { return nullptr; } void ProcessLogin(); private: mutex _mutex; //map\u0026lt;int32, Account*\u0026gt; _accounts; } User Manager\nclass User { //TEMP } public: static UserManager* Instance() { static UserManager instance; return \u0026amp;instance; } User* GetUser(int32 id) { return nullptr; } void ProcessSave(); private: mutex _mutex; //map\u0026lt;int32, User*\u0026gt; _users; } 이처럼 각각의 매니저는 mutex 를 갖고있고, ProcessLogin 과 ProcessSave 라는 기능이 있다.\n여기서 AccountManager 의 ProcessLogin 함수에 다음과 같은 로직이 구현된다.\nvoid AccountManager::ProcessLogin() { //AccountManager 의 mutex 획득 시도 std::lock_guard\u0026lt;mutex\u0026gt; guard(_mutex); //UserManager 의 mutex 획득 시도 User* user = UserManager::Instance()-\u0026gt;GetUser(100); //Something... } AccountManager 의 mutex 를 잡은 다음에, UserManager 의 mutex 또한 획득하려 한다.\n그런데 이제 필요에 의해 UserManager 의 ProcessSave 또한 다음과 같은 로직이 구현된다.\nvoid UserManager::ProcessSave() { //UserManager 의 mutex 획득 시도 std::lock_guard\u0026lt;mutex\u0026gt; guard(_mutex); //AccountManager 의 mutex 획득 시도 User* user = AccountManager::Instance()-\u0026gt;GetAccount(100); //Something... } UserManager 의 mutex 를 잡은 다음에, AccountManager 의 mutex 를 획득하려 한다.\n이제 다음과 같이 여러번 호출하는 상황을 만들어 문제가 없는지 확인해보자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026#34;AccountManager.h\u0026#34; #include \u0026#34;UserManager.h\u0026#34; void Func1() { for(int i = 0; i \u0026lt; 1000; ++i) { UserManager::Instance()-\u0026gt;ProcessSave(); }\t} void Func2() { for(int i = 0; i \u0026lt; 1000; ++i) { AccountManager::Instance()-\u0026gt;ProcessLogin(); } } int main() { std::thread t1(Func1); std::thread t2(Func2); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; \u0026#34;Jobs Done\u0026#34; \u0026lt;\u0026lt; std::endl; } 실행해보니 Jobs Done 이 출력되지 않는다.\nUserManager 는 AccountManager 의 락을 획득하려 한다.\nAccountManager 는 UserManager 의 락을 획득하려 한다.\n서로가 서로의 락이 풀리기를 기다리는 교착 상태에 빠져버렸다.\nSolution # 위와 같은 상황은 락을 잡는 순서를 맞춰주면 해결할 수 있다.\n일단 UserManager 의 ProcessSave 가 다음과 같이 바뀐다면 해결된다.\nvoid UserManager::ProcessSave() { //AccountManager 의 mutex 획득 시도 User* user = AccountManager::Instance()-\u0026gt;GetAccount(100); //UserManager 의 mutex 획득 시도 std::lock_guard\u0026lt;mutex\u0026gt; guard(_mutex); //Something... } AccountManager 의 ProcessLogin 과 락을 잡는 순서를 맞춰주면 되는 것이다.\n반대로 AccountManager 가 UserManager 의 ProcessSave 와 동일한 락 순서를 만들어도 된다.\n하지만, 이건 이렇게 간단한 상황일때나 가능한 이야기고, 사용하는 스레드와 뮤텍스가 많아지면 일일히 순서를 관리하는 것은 너무 어렵다.\nConclusion # 락을 거는 순서에 유의하여 락을 걸어야 한다.\n추후 락을 거는 순서에 싸이클이 발생하는지 탐지하는 알고리즘을 이용하여 이러한 문제 상황을 쉽게 확인할 수 있도록 해야한다.\nstd::lock # std::lock은 C++11에서 도입된 기능으로, 여러 개의 std::mutex를 Dead Lock 없이 한번에 잠그기 위해 사용한다.\nstd::lock은 여러 개의 std::mutex 객체를 인자로 받아, 그 중 어떤 것도 잠기지 않은 상태에서 모든 뮤텍스를 한 번에 잠근다.\n만약 일부 뮤텍스가 이미 잠겼다면, std::lock 은 필요한 모든 뮤텍스가 풀릴 때까지 기다린 다음, 그것들을 한번에 잠근다.\n한 번에 잠그기 때문에 교착 상태가 일어날 가능성이 줄어든다.\nstd::mutex m1, m2; std::lock(m1, m2); // 두 뮤텍스를 한번에 잠금 (잠기는 순서는 상관없음) std::adpot_lock # std::lock 을 이용해 한 번에 여러개의 mutex 를 획득 했다고 치자.\nstd::lock 공유 자원을 건드는 일을 마친 후 다시 락을 반환해 주어야 한다.\n이미 std::lock_guard 를 통해 RAII 패턴으로 함수를 벗어나면 락을 풀어줄 수 있는 방법이 있다.\n하지만, std::lock_guard 는 인자로 넘어온 mutex 를 즉시 잠구려고 시도한다.\n이미 잠긴 mutex 를 다시 잠구려고 시도하면 또다시 Dead Lock 이 발생한다.\n잠긴 mutex 를 풀어주기 전까진 다시 잠굴 수 없기 때문이다. (이를 위해 std::recursive_lock 이 있긴 한데 지금은 몰라도 된다.)\n아래의 코드와 같은 상황이라고 보면 된다.\n#include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex mtx; void DoubleLock() { mtx.lock(); mtx.lock(); mtx.unlock(); mtx.unlock(); } int main() { std::thread t1(DoubleLock); t1.join(); return 0; } 이럴때 std::adopt_lock 을 사용하면 문제를 해결할 수 있다.\nstd::adopt_lock 은 인자로 넘어온 뮤텍스가 이미 잠겨 있음을 인지하고, 추가로 잠그지 말고 나중에 소멸될 때 락을 풀어주기만 해라 라는 의미이다.\nstd::mutex mtx1, mtx2; void MultiMutex() { std::lock(mtx1, mtx2); // mtx1과 mtx2를 동시에 잠근다. // 아래의 lock_guard는 mtx1과 mtx2가 이미 잠겼음을 \u0026#34;인지\u0026#34;하고, 추가로 잠그려고 시도하지 않는다. std::lock_guard\u0026lt;std::mutex\u0026gt; lock1(mtx1, std::adopt_lock); std::lock_guard\u0026lt;std::mutex\u0026gt; lock2(mtx2, std::adopt_lock); // ... 임의의 (공유 자원에 대한) 작업 ... // lock1과 lock2가 소멸되면 mtx1과 mtx2는 자동으로 해제된다. } ","date":"2023-08-13","permalink":"/posts/game-server-development/4-deadlock/","section":"Posts","summary":"Dead Lock","title":"Game Server Development #4 : Dead Lock"},{"content":" Material # [C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버\nWhat is Lock # Lock(락) 은 동시에 여러 스레드에 의해 접근될 수 있는 데이터나 자원인 공유 자원의 동시 접근을 제어하고자 할 때 사용한다.\n락을 쉽게 이해하는 방법은, 실생활에서 사용하는 자물쇠를 생각해보면 된다.\n예를 들어, 두 사람이 한 개의 화장실을 사용하고 싶을 때, 먼저 도착한 사람이 화장실을 사용하게 되고, 그 사람이 사용하는 동안 다른 사람은 기다려야 한다.\n이때 화장실에 자물쇠를 걸어 다른 사람이 사용하지 못하게 한다고 생각하면 된다.\n비슷하게, 한 스레드가 공유 자원에 접근하기 위해 락을 획득(잠금)하면, 그 스레드만 해당 자원에 접근할 수 있고, 다른 스레드들은 그 락이 해제(잠금 해제)될 때까지 기다려야 한다.\n이렇게 락을 사용하면 여러 스레드가 동시에 같은 자원에 접근하는 것을 막아 데이터의 무결성을 유지할 수 있다.\nProblem # 필요성을 느끼기 위해 문제가 되는 상황을 먼저 확인 해보자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; std::vector\u0026lt;int\u0026gt; v; void Push() { for (int i = 0; i \u0026lt; 1\u0026#39;0000; ++i) { v.push_back(i); } } int main() { std::thread t1(Push); std::thread t2(Push); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; std::endl; return 0; } 가장 먼저 이 코드는 런타임 에러. 즉, 크래시가 발생한다.\n이유는 다음과 같다.\nv 의 값이 채워지며, capacity 를 넘는 데이터 삽입 요청이 발생하는 경우, v 의 capacity 를 늘리기 위해 메모리를 재할당한다.\nt1 스레드가 요청한 삽입을 처리하기 위해 v 의 capacity 를 늘리기 위해 메모리를 재할당하고 있는 도중 t2 스레드가 v 에 데이터를 삽입한다면, t2 스레드가 접근하려는 메모리는 해제된 메모리이기 때문에, 재할당한 메모리에 접근할 수 없게 되어 런타임 에러가 발생한다.\n또 한편으로는 동시에 두 스레드 모두가 재할당을 요청하는 문제도 생길수도 있다.\n그럼 만약 v 가 재할당이 일어나지 않았다면 문제가 없을까?\n결론부터 말하자면, 그렇지 않다.\n두 스레드가 동시에 v 의 size 를 확인하고, 그 값에 1을 더한 값을 v 에 추가하려고 할 것이다.\n이때, 두 스레드가 동시에 size 를 확인하면, 서로 같은 값을 반환할 것이다.\n그 상태에서 두 스레드가 size 에 1을 더한 값을 v 에 추가하려고 할 것이다.\n이러면 v 에는 1개의 값만 추가되었을 것이다.\n2 가지의 다른 문제가 있지만 결국 이러한 문제를 Race Condition(경쟁 상태) 라고 한다.\nMutual Exclusion # Lock 을 사용하여 문제를 해결해보자.\nC++ 에서 락을 사용하기 위해서는 mutex 라는 클래스를 사용한다.\nmutex 는 Mutual Exclusion(상호 배제) 라는 의미를 가지고 있다.\nmutex 는 lock 과 unlock 이라는 직관적인 함수를 통해 사용할 수 있다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;mutex\u0026gt; std::vector\u0026lt;int\u0026gt; v; std::mutex m; void Push() { for (int i = 0; i \u0026lt; 1\u0026#39;0000; ++i) { m.lock(); v.push_back(i); m.unlock(); } } int main() { std::thread t1(Push); std::thread t2(Push); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; std::endl; return 0; } \u0026lt;mutex\u0026gt; 헤더를 추가하고, std::mutex 객체를 생성한다. 경쟁이 발생할 위험이 있는 부분에 lock 함수를 호출하여 락을 획득한다. 락을 획득한 후, 공유 자원에 접근한다. 만약 락을 획득하지 못했다면, 그 스레드는 접근하려는 락이 해제될 때까지 대기한다. 공유 자원에 접근이 끝나면 unlock 함수를 호출하여 락을 해제한다. 더 쉽게 보면, 자물쇠(mutex) 를 잠그고 (lock) 사용하고, 사용이 끝나면 자물쇠를 푼다 (unlock) 는 개념이다.\nmutex의 lock 안의 구간은 싱글 스레드로 동작하는 것과 같다. 단 하나의 스레드의 접근만 허용하기 때문이다.\nDead Lock # 락을 잠궈두고 unlock 을 하지 않는다면, 그 락은 영원히 해제되지 않는다.\n그리고 그 락이 풀리길 기다리는 다른 스레드들은 영원히 대기하는 상태에 빠지고 만다.\n이와 같이 비정상적인 락의 상황 때문에 스레드들이 무한정 대기하는 상황을 Dead Lock(데드락) 이라고 한다.\nDead Lock 은 두 개 이상의 프로세스나 스레드가 서로의 자원을 기다리며 영원히 진행되지 못하는 상태를 의미한다.\n다음과 같은 코드를 보자.\n#include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;mutex\u0026gt; std::vector\u0026lt;int\u0026gt; v; std::mutex m; void Push() { for (int i = 0; i \u0026lt; 1\u0026#39;0000; ++i) { m.lock(); v.push_back(i); if (i == 5000) break; m.unlock(); } } 개발을 하다보면 위처럼 다양한 분기와 처리를 진행하게 된다.\n이럴때 실수로 위와같이 i 가 5000 에 도달할 경우, 락을 해제하지 않고 함수를 빠져 나가는 실수를 할 수 있다.\n조건문 안에 m.unlock() 을 넣어 해결할 수도 있지만, 만약 저 코드가 다양한 내용을 처리하는 100줄 이상의 함수였다면, 그 조건문을 찾기도 힘들고, 또 다른 조건문을 추가할 때마다 unlock 을 추가해야 한다.\n이는 매우 귀찮고, 번거로우며, 실수하기 딱 좋은 상황이 된다.\n위처럼 단순한 예는 그나마 금방 찾을 수 있지만, 실제로는 더 복잡한 Dead Lock 상황이 발생할 수 있으므로 조심해야한다.\nLock Guard # 위와 같은 Dead Lock 상황을 미연에 방지하기 위해 std::lock_guard 라는 클래스를 사용할 수 있다.\nstd::lock_guard 는 mutex 를 생성자에서 획득하고, 소멸자에서 해제하는 클래스이다.\n이렇게 하면 스코프를 벗어나는 순간 mutex 가 해제되기 때문에, unlock 을 신경쓰지 않아도 된다.\n이러한 방식을 RAII(Resource Acquisition Is Initialization) 라고 한다.\nstd::lock_guard 를 사용하면 다음과 같이 코드를 작성할 수 있다.\n#include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;mutex\u0026gt; std::vector\u0026lt;int\u0026gt; v; std::mutex m; void Push() { for (int i = 0; i \u0026lt; 1\u0026#39;0000; ++i) { std::lock_guard\u0026lt;std::mutex\u0026gt; lockGuard(m); v.push_back(i); if (i == 5000) break; } } 명시적인 unlock 을 신경쓸 필요가 없게 되어 더 안전한 코드를 작성할 수 있다.\nRAII 는 꽤나 간단한 개념이므로, 아래와 같이 직접 Wrapper 를 만들어 Lock Guard 를 만들어 쓸 수도 있다.\n#include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;mutex\u0026gt; std::vector\u0026lt;int\u0026gt; v; std::mutex m; template\u0026lt;typename T\u0026gt; class LockGuard { public: LockGuard(T\u0026amp; mutex) : m_mutex(mutex) { m_mutex.lock(); } ~LockGuard() { m_mutex.unlock(); } private: T* m_mutex; } void Push() { for (int i = 0; i \u0026lt; 1\u0026#39;0000; ++i) { LockGuard\u0026lt;std::mutex\u0026gt; lockGuard(m); v.push_back(i); if (i == 5000) break; } } Unique Lock # 위에서 보았던 std::lock_guard 는 mutex 를 생성자에서 획득하고, 소멸자에서 해제하는 클래스이다.\n이러한 방식은 생성하자마자 mutex 를 획득하기 때문에 lock 을 거는 시점을 제어할 수 없다는 단점이 있다.\n이러한 점을 보완하기 위해 std::unique_lock 을 사용할 수 있다.\nstd::unique_lock 은 원한다면 락을 거는 시점을 조절할 수 있다.\nunique_lock 을 생성할 때, std::defer_lock 을 옵션으로 제공하면, 바로 mutex 를 획득하려 하지 않는다.\n명시적으로 lock 함수를 호출하는 순간에 mutex 를 획득한다.\n만약 아무 옵션도 없이 그냥 unique_lock 을 mutex 를 넣어 생성하면, 곧바로 락을 획득한다.\n#include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;mutex\u0026gt; std::vector\u0026lt;int\u0026gt; v; std::mutex m; void Push() { for (int i = 0; i \u0026lt; 1\u0026#39;0000; ++i) { std::unique_lock\u0026lt;std::mutex\u0026gt; uniqueLock(m, std::defer_lock); if(i == 0) continue; uniqueLock.lock(); v.push_back(i); if (i == 5000) break; } } Lock Guard vs Unique Lock # std::lock_guard 와 std::unique_lock 의 차이점은 다음과 같다.\nstd::lock_guard\n간단하고 빠른 mutex 락을 위한 클래스이다.\n객체를 생성할 때 mutex가 자동으로 잠기고, 객체가 소멸될 때 자동으로 잠금이 해제된다.\n경량 클래스이며, 별도의 조작(잠금 해제/재잠금)이 필요 없을 때 사용하는 것이 좋다.\nstd::unique_lock\nstd::lock_guard 보다 더 많은 유연성을 제공한다.\nstd::unique_lock을 사용하면 임의의 위치에서 수동으로 mutex 를 잠글 수 있다.\n더 유연하기 때문에 기능을 위한 구현이 추가되어, std::lock_guard 보다는 조금 더 무겁고 느린 구현이다.\n","date":"2023-08-12","permalink":"/posts/game-server-development/3-lock/","section":"Posts","summary":"Lock","title":"Game Server Development #3 : Lock"},{"content":"","date":"2023-08-11","permalink":"/tags/atomic/","section":"Tags","summary":"","title":"Atomic"},{"content":" Material # [C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버\nRace Condition # 먼저 아래의 코드를 보자.\n#include \u0026lt;iostream\u0026gt; int sum = 0; void Add() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { sum++; } } void Sub() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { sum--; } } int main() { Add(); Sub(); std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 이 코드의 결과 값은 0 이다.\n스레드를 이용해도 동일한지 확인 해보자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; int sum = 0; void Add() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { sum++; } } void Sub() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { sum--; } } int main() { std::thread t1(Add); std::thread t2(Sub); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 이 코드의 결과 값은 0 이 아니다.\n이유를 알아보자\nAdd 함수에서 일어나는 sum++ 을 디스어셈블리를 통해 본다면 다음과 같은 CPU 인스트럭션이 실행된다.\n00007FF64BAC2685 mov eax,dword ptr [sum (07FF64BAD0444h)] 00007FF64BAC268B inc eax 00007FF64BAC268D mov dword ptr [sum (07FF64BAD0444h)],eax 3줄의 어셈블리 코드가 실행되는데, 해석해보면 다음과 같다.\nsum 의 값을 eax 레지스터에 저장한다. eax 레지스터의 값을 1 증가시킨다. eax 레지스터의 값을 다시 sum 에 저장한다. (Sub 함수에서도 값을 감소시키는 것만 다를 뿐, 동일한 과정을 거친다.)\n위 내용을 C++ 코드로 표현하면 다음과 같다.\nint eax = sum; eax = eax + 1; sum = eax; 우리가 보는 한 줄의 C++ 코드는 컴파일을 거친 후, CPU 에서 실행되기 위한 3 줄의 어셈블리 코드로 변환되었다.\nCPU 에서는 메모리에서 어떤 값을 레지스터에 꺼내오고, 연산을 수행하고, 다시 메모리에 값을 저장하는 과정들을 각각 진행시키기 때문이다.\n이제 다시 본론으로 돌아와서 문제가 되는 상황을 보자.\nt1 과 t2 스레드는 동시에 실행되기 때문에 전역 변수 sum 을 동시에 접근하게 된다. 그리고 어떤 스레드가 먼저 실행될지, 언제 실행될지도 알 수 없다.\nt1 스레드에서 eax 레지스터에 sum 의 값을 저장하고 eax 의 값을 올린다. (eax = 1, sum = 0) t2 스레드에서 eax 레지스터에 sum 의 값을 저장하고 eax 의 값을 내린다. (eax = -1, sum = 0) t1 스레드에서 Context Switch 가 발생하여, eax 의 값을 sum 에 넣는 명령을 실행하기 직전인 상태로 대기한다. t2 스레드는 eax 의 값을 sum 에 넣는 명령을 실행한다. (eax = -1, sum = -1) t1 스레드가 다시 CPU Time 을 획득하여, eax 의 값을 sum 에 넣는다. (eax = 1, sum = 1) sum 의 값은 0 이 아닌 1 이 된다. 결국 t2 의 연산이 무시되고, t1 의 연산만 반영된 것이다.\n이처럼 여러 스레드가 공유 자원을 동시에 변경할 때, 명령 순서에 따라 결과 값이 의도와 달라질 수 있는 상태를 경쟁 상태 (Race Condition) 라고 한다.\nSynchronization # 위와 같은 경쟁 상태를 해결하기 위해선, 공유 자원에 대한 접근 순서를 보장 해야 한다.\n접근 순서를 보장하는 것을 동기화 (Synchronization) 라고 한다.\n동기화에는 Mutex, Condition Variable, Atomic Operation 등등 여러가지 기법들이 존재한다.\n그 중에서도 가장 직관적인 Atomic Operation 을 이용해 지금의 경쟁 상태를 해결해보자.\nAtomic Operation # Atom(원자) 는 더 이상 쪼갤 수 없는 단위를 의미한다.\n비슷한 맥락으로 Atomic Operation(원자적 연산) 은 다른 스레드 간섭 없이, 연산이 한 번에 완료됨을 보장하는 연산 을 의미한다.\n조금 더 쉽게 말해보면 전부 실행이 되거나, 전혀 실행되지 않거나 둘 중 하나의 상태만 가능한 All or Nothing 연산이라고 할 수 있다.\n즉, 연산이 완료되기 전까지는 다른 스레드가 접근할 수 없다. (연산을 쪼갤 수 없다)\n위에서 문제가 되었던 sum++ 가 한 번에 이뤄짐을 보장해 주었다면, Race Condition 은 발생하지 않았을 것이다.\n그럼 아까의 문제 상황을 해결하기 위해 코드를 원자적 연산으로 바꿔보자.\nC++ 에서는 표준으로 원자적 연산을 지원한다. atomic 헤더를 추가하고, std::atomic 템플릿을 이용하면 된다.\nsum 의 타입을 atomic\u0026lt;int\u0026gt; 로 변경해보자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;atomic\u0026gt; std::atomic\u0026lt;int\u0026gt; sum = 0; void Add() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { sum.fetch_add(1); } } void Sub() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { sum.fetch_add(-1); } } int main() { std::thread t1(Add); std::thread t2(Sub); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 이 코드의 결과 값은 0 이다.\nAdd 함수의 fetch_add 함수는 원자적으로 동작하기 때문에, sum 의 값을 읽어오고, 1 을 더한 후, 다시 sum 에 저장하는 과정이 한 번에 이뤄진다.\n만약, Add 함수의 sum 변수에 대한 연산이 진행중인 상태에서 Sub 함수가 sum 변수에 접근하려고 하면, Sub 함수는 Add 함수의 연산이 완료될 때까지 대기하게 된다.\n이렇게 대기 시키는 것은 CPU 명령으로 구현되어 있어서, CPU 단에서 원자성을 보장해준다.\n그럼 Atomic 을 모든 곳에 때려 박으면 모든 문제가 해결되는 것일까?\n아쉽게도 그렇지 않다.\nIssue of Atomic Operation # Atomic 은 퍼포먼스를 떨어뜨리는 요소이기 때문에, 필요한 부분에만 사용해야 한다.\n퍼포먼스가 떨어지는 이유들은 다음과 같다.\nMemory Barrier/Fence # 메모리 배리어(Memory Fence 라고도 함) 는 프로세서가 명령어를 재배치하는 것을 제한하거나 금지하여, 특정 명령들이 원하는 순서대로 실행되도록 보장하는 것을 말한다.\n이는 멀티 스레딩 환경에서 매우 중요하다.\n성능 향상을 위해서 최신 CPU는 자원을 최대한 활용하기 위해 명령어를 순서 없이 실행하는 경우가 많다.\n하드웨어가 명령어 무결성을 적용하기 때문에 단일 실행 스레드에서는 이를 알아차리지 못한다. 그러나, 여러 스레드가 있는 환경에서는 예측할 수 없는 동작으로 이어질 수 있다.\n메모리 배리어는 메모리 읽기/쓰기가 예상한 순서대로 발생한다는 것을 의미하는 명령어다.\n메모리 배리어는 하드웨어 개념이라는 점을 유의하자.\nCPU 의 하드웨어 단에서 이뤄지는 재정렬은 컴파일러 최적화와는 다르다.\nWhy # 메모리 베리어가 필요한 이유는, 멀티 스레딩 환경에서는 여러 스레드가 동일한 메모리에 액세스하므로, 명령어의 실행 순서가 예상과 다를 경우 데이터의 일관성이 깨질 수 있다.\n예를 들어, 스레드 A와 스레드 B가 있을 때, A가 변수 x를 1 로 설정하고 B가 그 값을 읽는 상황을 생각해보자.\n메모리 배리어가 없다면, B가 x를 읽은 후에 A가 x를 1 로 설정할 수 있다.\n이런 상황을 피하기 위해 메모리 배리어가 사용된다.\nHow # 메모리 배리어를 설정하면, 그 앞뒤의 명령어들은 배리어를 넘어서 재배치되지 않는다.\n즉, 배리어 앞의 명령어들은 배리어가 실행되기 전에 완료되고, 배리어 뒤의 명령어들은 배리어가 실행된 후에만 실행된다.\n예를 들어, 아래와 같은 코드를 보자.\nx = 1; // 스레드 A memory_barrier(); y = 2; // 스레드 A 이 경우, y = 2는 x = 1이 완료된 후에만 실행된다.\n이렇게 메모리 배리어를 사용하면 명령어의 실행 순서를 보장할 수 있다.\n순서를 보장하지만, 최적화가 무시될 가능성이 높으므로, 그로 인한 성능 저하가 발생할 수 있다.\nReference # https://code-piggy.tistory.com/171 https://stackoverflow.com/a/286705 https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%B0%B0%EB%A6%AC%EC%96%B4 Bus Lock # 버스 락은 한 스레드가 데이터에 액세스하는 동안 다른 스레드가 그 데이터를 수정하지 못하게 하는 것을 말한다.\n두 스레드가 동시에 같은 메모리 위치를 수정하려고 할 때, 버스 락을 통해 한 번에 한 스레드만 수정할 수 있도록 제어 한다.\nCache Coherency # 멀티 코어 시스템에서 각 코어의 캐시는 다른 코어의 캐시와 일관성을 유지해야 한다. 이를 캐시 일관성 이라고 한다.\n한 스레드가 코어 A의 캐시에 있는 데이터를 수정하면, 이 변경 사항은 코어 B의 캐시에도 반영되어야 한다.\n이를 위해 추가적인 통신과 동기화가 필요하다. 이 부분에서 성능 저하가 발생한다.\nCache Invalidation # 캐시 무효화는 한 코어에서 캐시에 저장된 특정 메모리 위치를 변경하면, 다른 코어의 캐시에서 그 위치의 데이터가 무효화되는 것을 말한다.\n이렇게 되면 다른 코어는 다시 메인 메모리에서 해당 데이터를 로드해야 한다.\n캐시 무효화는 메모리 액세스 시간에 큰 영향을 미친다.\n캐시에서 빠르게 데이터를 가져오는 대신, 더 느린 메인 메모리(RAM)에서 데이터를 가져와야 해서, 성능에 영향을 줄 수 있다.\nCache Line Ping Pong # 두 개 이상의 코어가 동일한 캐시 라인의 데이터를 수정할 경우, 해당 캐시 라인은 코어 간에 빠르게 이동하게 된다.\n이를 핑퐁(Ping Pong) 이라고 한다.\n캐시 라인 핑퐁은 데이터를 캐시에 유지하기 어렵게 만들어, 빈번한 캐시 무효화와 메인 메모리 액세스를 유발한다.\n이로 인해 성능이 크게 저하될 수 있다.\nRetring # 일부 원자적 연산은 성공할 때까지 여러 번 시도될 수 있다.\nCompare and Swap # Compare and Swap (CAS) 연산은 원래의 값과 비교하여 값이 같으면 새 값을 저장한다.\n동시성 환경에서 변경이 필요한 값의 Memory\n최종적으로 변화하길 원하는 값인 Desired\n변화를 만들기 위한 조건으로 기대하고 있는 값인 Expected\n위 3 가지 요소들을 가지고 비교와 변경을 진행한다.\n또한, 원래의 값(Memory) 이 다른 스레드에 의해 도중에 변경되면 연산은 실패하고 재시도 된다.\nCAS 를 C++ 에서 사용할 때는 다음과 같은 함수가 사용된다.\ntemplate\u0026lt; class T \u0026gt; bool atomic_compare_exchange_strong( std::atomic\u0026lt;T\u0026gt;* obj, typename std::atomic\u0026lt;T\u0026gt;::value_type* expected, typename std::atomic\u0026lt;T\u0026gt;::value_type desired ) noexcept; bool std::atomic_compare_exchange_strong(Memory, Expected, Desired); //weak 도 있다. 위의 CAS 를 의사 코드로 표현해보면 다음과 같다.\nif (Memory == Expected) { Expected = Memory; Memory = Desired; return true; } else { Expected = Memory; return false; } ","date":"2023-08-11","permalink":"/posts/game-server-development/2-atomic/","section":"Posts","summary":"Race Condtion, Atomic","title":"Game Server Development #2 : Race Condtion, Atomic"},{"content":" Material # [C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버\nIntroduction # 서버 프로그래밍은 식당을 운영하는 것과 비슷하다.\n식당 : 프로세스 (그림판, 메모장, 게임 서버 등등)\n직원 : 스레드\n영혼 : CPU 코어\n식당에는 주방, 서빙, 청소 등을 담당하는 직원들이 있고, 각각의 직원들은 자신의 역할을 혼자서 또는 여럿이서 수행한다.\n현실과는 살짝 다른 부분이 있다면, 식당 관리자(운영체제) 가 존재하고, 영혼이 직원에게 들어가 있을 때(CPU Time 을 가졌을 때) 만 일을 한다고 보면 된다.\n어떤 식당을 운영하느냐에 따라 직원의 수가 달라지고, 직원의 역할이 달라진다.\n간단한 음식을 파는 가게라면 혼자서도 운영할 수 있다.\n게임 서버라면 단일 스레드로도 충분할 수 있다.\n큰 식당은 혼자서 감당할 수 없다. 여러 직원들이 각자의 역할을 수행하며 식당을 운영해야 한다.\n같은 맥락으로, MMO 같은 대규모 인원이 접속하여 다량의 데이터와 입력을 처리해야하는 경우, 멀티 스레드 구조를 사용하는 것이 필수적이다.\n이제 스레드를 사용하여 멀티 스레드 프로그래밍에 대해 알아보자.\nThread # 스레드는 프로세스 내에서 실행되는 흐름의 단위이다.\n프로세스는 최소 하나의 스레드를 가지고 있다.\n스레드는 프로세스 내의 Code, Data, Heap 메모리를 공유한다.\nStack 은 각각의 스레드에 따로 존재한다.\n사진으로 보면 아래와 같다.\nBasic Thread Usage # C++ 에서 스레드를 사용하는 기본적인 방법은 아래와 같다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; void HelloThread() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello Thread\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::thread t(HelloThread); t.join(); return 0; } 위 코드의 결과는 다음과 같다.\nHello Thread thread 헤더를 include 하고, std::thread 를 사용하여 스레드를 생성한다.\nstd::thread 생성자의 인자로 함수를 넘겨주면, 해당 함수를 새로운 스레드로 실행한다.\njoin 을 호출하여 스레드가 종료될 때까지 기다린다.\nPostpone Thread Execution # 스레드를 생성하고 곧바로 사용하는 방법도 있지만, 아래와 같이 생성만 하고 나중에 사용할 수도 있다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; void HelloThread() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello Thread\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { // thread 객체만 생성. 실행은 하지 않음. std::thread t; // 나중에 실행 t = std::thread(HelloThread); t.join(); return 0; } Passing Arguments # 스레드가 실행할 함수에 대한 인자를 넘겨주는 방법은 아래와 같다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; void HelloThread(int n) { std::cout \u0026lt;\u0026lt; \u0026#34;Hello Thread #\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; std::endl; } int main() { std::thread t(HelloThread, 1); t.join(); return 0; } 위 코드의 결과는 다음과 같다.\nHello Thread #1 Thread ID # 스레드는 각각 고유한 ID 를 가지고 있다.\nget_id 함수를 사용하여 스레드의 ID 를 얻을 수 있다.\n이 ID 를 사용하여 스레드를 구분할 수 있다.\n발급된 ID 는 다른 스레드와 겹치지 않음을 보장하며, 랜덤하게 지정된다.\nID 는 스레드가 실행되고 있지 않은 경우 0 을 반환한다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; void HelloThread() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello Thread\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::thread t = std::thread(HelloThread); std::cout \u0026lt;\u0026lt; t.get_id() \u0026lt;\u0026lt; std::endl; t.join(); std::cout \u0026lt;\u0026lt; t.get_id() \u0026lt;\u0026lt; std::endl; return 0; } 위 코드의 결과는 다음과 같다.\n29836 Hello Thread 0 스레드가 종료되기 전에는 29836 이라는 ID 를 가지고 있었다.\n스레드가 join 을 넘어 종료된 이후, 다시 ID 를 얻어오면 0 이 반환된다.\nJoinable # 스레드는 현재 사용되고 있는지에 대한 체크를 위해 joinable 함수를 제공한다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; void HelloThread() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello Thread\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::thread t = std::thread(HelloThread); std::cout \u0026lt;\u0026lt; t.joinable() \u0026lt;\u0026lt; std::endl; t.join(); std::cout \u0026lt;\u0026lt; t.joinable() \u0026lt;\u0026lt; std::endl; return 0; } 위 코드의 결과는 다음과 같다.\n1 Hello Thread 0 joinable 함수는 구체적으로 *this 의 get_id 의 반환값이 std:🧵:id()(기본값) 와 다른지 체크한다.\nget_id() != std:🧵:id() 따라서 비활성 상태의 스레드는 joinable 하지 않다.\n스레드가 실행을 완료했지만, 아직 join 되지 않은 스레드는 여전히 활성 상태로써 실행되고 있는 스레드로 간주되므로 joinable 하다.\nHardware Concurrency # 스레드를 생성할 때, hardware_concurrency 함수를 사용하여 현재 시스템에서 지원하는 최대 스레드 개수의 hint 를 얻을 수 있다.\n이 값은 hint 로써 제공되며, 100% 신뢰해서는 안된다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; int main() { unsigned int n = std:🧵:hardware_concurrency(); std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; std::endl; return 0; } 현재 사용중인 Ryzen 3700X CPU 는 8 코어 16 스레드 CPU 이며, 위 코드의 결과는 다음과 같다.\n16 논리 스레드의 갯수를 반환해준다고 보면 된다.\n","date":"2023-08-08","permalink":"/posts/game-server-development/1-thread/","section":"Posts","summary":"Introduction \u0026amp; Thread","title":"Game Server Development #1 : Introduction, Thread"},{"content":"I have been working in the game industry since 2019. As a game programmer, my main goals are fast and accurate implementation of requested game content, understanding the specific needs of developers from different fields and collaborating with them to deliver great game content.\nI prefer an environment where I can experience success and failure faster, learn faster, and have a greater overall impact.\nI\u0026rsquo;m currently focused on improving my skills. I\u0026rsquo;m trying to write about my experiences, topics I\u0026rsquo;m currently interested in, or things I\u0026rsquo;m learning, and I\u0026rsquo;d love to get your feedback on that. I also want to help other programmers or people who want to get into game development.\nFeel free to reach out.\nExperience Company Link Role Project Genre Dates Location PUBG STUDIO Gameplay Programmer PUBG: Battlegrounds Battle Royale 2022 - Present Seoul, KR KRAFTON Gameplay Programmer Project D Soul Like\nAction Adventure\nRPG 2021 - 2022 Seoul, KR EVR STUDIO Client Programmer Project TH TPS Action Adventure 2019 - 2021 Seoul, KR Education School Link Degree Date ChungKang College of Cultural Industries Intensified course completion of major 2020 Game Contents 2017-2019 Project Logo Title Description Link Lua Tonic Unreal Engine ❤️ Lua Github Project V Korean Dark Soul UE DualSense DualSense Controller Support for\nUnreal Engine Github SoyCrab Physics Engine Game Physics Engine Development Github AWAKE Graduational Project Youtube ","date":"2022-06-13","permalink":"/about/","section":"","summary":"I have been working in the game industry since 2019. As a game programmer, my main goals are fast and accurate implementation of requested game content, understanding the specific needs of developers from different fields and collaborating with them to deliver great game content.","title":"About"},{"content":"I have been working in the game industry since 2019. As a game programmer, my main goals are fast and accurate implementation of requested game content, understanding the specific needs of developers from different fields and collaborating with them to deliver great game content.\nI prefer an environment where I can experience success and failure faster, learn faster, and have a greater overall impact.\nI\u0026rsquo;m currently focused on improving my skills. I\u0026rsquo;m trying to write about my experiences, topics I\u0026rsquo;m currently interested in, or things I\u0026rsquo;m learning, and I\u0026rsquo;d love to get your feedback on that. I also want to help other programmers or people who want to get into game development.\nFeel free to reach out.\nExperience Company Link Role Dates Location PUBG STUDIO Gameplay Programmer 2022.01.03 - Present Hybrid Seoul, KR KRAFTON Gameplay Programmer 2021 - 2022 Seoul, KR EVR STUDIO Client Programmer 2019.07.29 - 2020.12.31 Seoul, KR Education School Link Degree Date ChungKang College of Cultural Industries Intensified course completion of major 2020 Game Contents 2017-2019 Project Logo Title Description Link Lua Tonic Unreal Engine ❤️ Lua Github Project V Korean Dark Soul UE DualSense DualSense Controller Support for\nUnreal Engine Github SoyCrab Physics Engine Game Physics Engine Development Github AWAKE Graduational Project Youtube ","date":"2022-06-13","permalink":"/authors/bbagwang/","section":"Authors","summary":"I have been working in the game industry since 2019. As a game programmer, my main goals are fast and accurate implementation of requested game content, understanding the specific needs of developers from different fields and collaborating with them to deliver great game content.","title":"BBAGWANG"},{"content":"","date":"2022-06-13","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"2022-04-23","permalink":"/tags/network/","section":"Tags","summary":"","title":"Network"},{"content":"","date":"2022-04-23","permalink":"/tags/optimize/","section":"Tags","summary":"","title":"Optimize"},{"content":"Unreal Engine 5 가 정식 출시하며 같이 뿌린 Lyra Shooter Project 를 개인적으로 분석하던중 예전부터 듣기만했던 Quantization 에 대해 알아볼 기회가 있어 정리해본다.\nLyra 프로젝트에서는 캐릭터의 Acceleration 관련 변수들을 업데이트하여 Character Movement에 계산시켜 이동을 동기화 시킬때 다음과 같은 구조체를 사용한다.\n/** * FLyraReplicatedAcceleration: Compressed representation of acceleration */ USTRUCT() struct FLyraReplicatedAcceleration { GENERATED_BODY() UPROPERTY() uint8 AccelXYRadians = 0; // Direction of XY accel component, quantized to represent [0, 2*pi] UPROPERTY() uint8 AccelXYMagnitude = 0; //Accel rate of XY component, quantized to represent [0, MaxAcceleration] UPROPERTY() int8 AccelZ = 0; // Raw Z accel rate component, quantized to represent [-MaxAcceleration, MaxAcceleration] }; 여기에서 Quantized to represent 라는 말이 나온다.\n1바이트 정수형 변수들에다 가속에 대한 각도, 크기, 수직값에 대한 정보를 기입하는데 이건 어떻게 넣어주는지 확인해봤다.\nvoid ALyraCharacter::PreReplication(IRepChangedPropertyTracker\u0026amp; ChangedPropertyTracker) { Super::PreReplication(ChangedPropertyTracker); if (UCharacterMovementComponent* MovementComponent = GetCharacterMovement()) { // Compress Acceleration: XY components as direction + magnitude, Z component as direct value const double MaxAccel = MovementComponent-\u0026gt;MaxAcceleration; const FVector CurrentAccel = MovementComponent-\u0026gt;GetCurrentAcceleration(); double AccelXYRadians, AccelXYMagnitude; FMath::CartesianToPolar(CurrentAccel.X, CurrentAccel.Y, AccelXYMagnitude, AccelXYRadians); ReplicatedAcceleration.AccelXYRadians = FMath::FloorToInt((AccelXYRadians / TWO_PI) * 255.0); // [0, 2PI] -\u0026gt; [0, 255] ReplicatedAcceleration.AccelXYMagnitude = FMath::FloorToInt((AccelXYMagnitude / MaxAccel) * 255.0); // [0, MaxAccel] -\u0026gt; [0, 255] ReplicatedAcceleration.AccelZ = FMath::FloorToInt((CurrentAccel.Z / MaxAccel) * 127.0); // [-MaxAccel, MaxAccel] -\u0026gt; [-127, 127] } } Replicate 시키기 전 체크하는 단계인 PreReplication 함수에서 현재 캐릭터의 가속도와 관련된 값들을 가져와 계산한다.\n실수값들을 모두 FloorToInt 를 사용해 정수형으로 변환시키고, 값들을 (u)int8 형이 표현할 수 있는 값의 범위 내의 값으로 Normalized 시켰다.\n이제 ReplicatedAcceleration 안에 들어간 변수들은 모두 특정 값에 대한 Ratio 가 되었다.\n그것도 double이 아닌 1바이트 정수형으로 말이다.\n이렇게 실수형 변수를 정수형 변수로 변환하는 과정을 Quantization (양자화) 라고 한다.\n양자화를 하는 이유는 크게 3가지 정도인 것 같다.\n네트워크 전송 최적화 double 의 경우 8바이트, float의 경우 4바이트 값을 1바이트 정수형으로 보내 네트워크 부하를 줄일 수 있다. 계산 속도 최적화 실수형 계산은 생각보다 느리다. double의 경우엔 더 느리다. double로 저장된 8바이트(64비트) 짜리 변수를 1바이트(8비트) 로 경량화 했으므로, 계산 복잡도가 줄어든다. 정수형 계산이 실수형 계산보다 상대적으로 빠르기 때문에 사용할 수 있다. 메모리, 디스크 최적화 8바이트 가져와서 쓸걸 1바이트의 정보만 가져와서 계산한다면, 메모리와 디스크 사용량이 최적화될 것이다. 양자화한값을 실수형이던 본래값으로 다시 돌려내야한다면, 기존 값이 어떤 범위를 갖고있었는지 알아야한다.\n위에서 보는 2PI 나 MaxAccel 같은 값을 알아야 원래 값으로 되돌릴 수 있다.\n아래 함수에서는 양자화되어서 Replicated 된 변수들을 가져와 다시 기존 값으로 복구시키는 코드이다.\n양자화를 했던 방식에 대한 역산이 이뤄진다.\nvoid ALyraCharacter::OnRep_ReplicatedAcceleration() { if (ULyraCharacterMovementComponent* LyraMovementComponent = Cast\u0026lt;ULyraCharacterMovementComponent\u0026gt;(GetCharacterMovement())) { // Decompress Acceleration const double MaxAccel = LyraMovementComponent-\u0026gt;MaxAcceleration; const double AccelXYMagnitude = double(ReplicatedAcceleration.AccelXYMagnitude) * MaxAccel / 255.0; // [0, 255] -\u0026gt; [0, MaxAccel] const double AccelXYRadians = double(ReplicatedAcceleration.AccelXYRadians) * TWO_PI / 255.0; // [0, 255] -\u0026gt; [0, 2PI] FVector UnpackedAcceleration(FVector::ZeroVector); FMath::PolarToCartesian(AccelXYMagnitude, AccelXYRadians, UnpackedAcceleration.X, UnpackedAcceleration.Y); UnpackedAcceleration.Z = double(ReplicatedAcceleration.AccelZ) * MaxAccel / 127.0; // [-127, 127] -\u0026gt; [-MaxAccel, MaxAccel] LyraMovementComponent-\u0026gt;SetReplicatedAcceleration(UnpackedAcceleration); } } Lyra 프로젝트에 볼게 정말 많은 것 같다. 많이 배우는중.\nReference\nhttps://gaussian37.github.io/dl-concept-quantization/#quantization-%EC%9D%B4%EB%9E%80-1\n","date":"2022-04-23","permalink":"/posts/old-blog/quantized-%EC%96%91%EC%9E%90%ED%99%94-%EB%90%98%EC%97%88%EB%8B%A4%EB%8A%94-%EC%9D%98%EB%AF%B8%EC%99%80-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/","section":"Posts","summary":"Quantized (양자화) 되었다는 의미와 사용하는 이유","title":"Quantized (양자화) 되었다는 의미와 사용하는 이유"},{"content":"","date":"2022-04-23","permalink":"/tags/unreal-engine/","section":"Tags","summary":"","title":"Unreal Engine"},{"content":"","date":"2022-04-23","permalink":"/categories/unreal-engine/","section":"Categories","summary":"","title":"Unreal Engine"},{"content":"","date":"2022-04-22","permalink":"/categories/english-post/","section":"Categories","summary":"","title":"English Post"},{"content":"If you want to collect class-specific actors that spawned in the world you can use TActorIterator.\nfor (TActorIterator\u0026lt;ACharacter\u0026gt; Iter(GetWorld()); Iter; ++Iter) { ACharacter* Character = *Iter; //If IsValid Character-\u0026gt;Func(); } There is also a version of the Ranged For feature available in C++11.\nIt\u0026rsquo;s called TActorRange. With this, we can iterate it safer and easier.\nfor (ACharacter* Character : TActorRange\u0026lt;ACharacter\u0026gt;(GetWorld())) { //If IsValid Character-\u0026gt;Func(); } ","date":"2022-04-22","permalink":"/posts/tactoriterator-and-tactorrange/","section":"Posts","summary":"TActorIterator and TActorRange","title":"TActorIterator and TActorRange"},{"content":"","date":"2022-04-22","permalink":"/categories/unrealengine/","section":"Categories","summary":"","title":"UnrealEngine"},{"content":"언리얼의 경우 빌드 환경이 DebugGame 이 아닌 경우 (Development. Shipping) 에 성능은 거의 그대로 유지한체, 일부 디버깅이 필요한 영역만 컴파일 최적화를 꺼서 디버깅할 수 있다.\n일반 C++ 코드에도 그대로 적용 가능하다.\n#pragma optimize(\u0026quot;\u0026quot;, off) 이후 작성한 모든 코드에 대해 컴파일 최적화를 끄고,\n#pragma optimize(\u0026quot;\u0026quot;, on) 을 한 시점부터 컴파일 최적화가 다시 켜진다.\n//컴파일 최적화 비활성화 #pragma optimize(\u0026#34;\u0026#34;, off) void AVCharacter::SetRotationMode(EVRotationMode NewRotationMode) { //컴파일 최적화가 꺼져서 변수 내용들이 잘 보임 } //컴파일 최적화 활성화 #pragma optimize(\u0026#34;\u0026#34;, on) void AVCharacter::CalculateVisualScore() { //컴파일 최적화가 위에서 켜져서 변수 내용들이 잘 안 보임 } ","date":"2022-04-03","permalink":"/posts/old-blog/c-compile-optimization-%EC%9D%BC%EB%B6%80%EB%B6%84%EB%A7%8C-%ED%95%B4%EC%A0%9C%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/","section":"Posts","summary":"C++ Compile Optimization 일부분만 해제하는 방법","title":"C++ Compile Optimization 일부분만 해제하는 방법"},{"content":"If you want to debug your code while you didn\u0026rsquo;t compile your project with the DebugGame setting.\nYou might end up with see an optimized variable in which you can\u0026rsquo;t see what\u0026rsquo;s in it.\nIn that case, you can disable optimization on a specific section of your code.\nLike this.\n#pragma optimize(\u0026#34;\u0026#34;, off) void AVCharacter::NotOptimized() { //Some Codes } #pragma optimize(\u0026#34;\u0026#34;, on) void AVCharacter::Optimized() { //Some Codes } ","date":"2022-04-03","permalink":"/posts/controlling-c++-compile-optimization/","section":"Posts","summary":"Controlling C++ Compile Optimization","title":"Controlling C++ Compile Optimization"},{"content":"When you have multiple PIE viewports, you might have some viewport focus issues.\nFor example, having spectator to player and input mode change make viewports do ping pong each other.\nIt only happens in PIE mode because it\u0026rsquo;s not a Standalone Game.\nHere\u0026rsquo;s the code on how to check my viewport is in focus.\n#if UE_EDITOR UWorld* World = GetWorld(); if (IsValid(World) \u0026amp;\u0026amp; World-\u0026gt;WorldType == EWorldType::PIE) { UGameViewportClient* GameViewportClient = World-\u0026gt;GetGameViewport(); if (!IsValid(GameViewportClient)) return; if (IsValid(GEngine) \u0026amp;\u0026amp; IsValid(GEngine-\u0026gt;GameViewport) \u0026amp;\u0026amp; (GEngine-\u0026gt;GameViewport-\u0026gt;Viewport != nullptr)) { const bool bIsFocusedViewport = GameViewportClient-\u0026gt;IsFocused(GEngine-\u0026gt;GameViewport-\u0026gt;Viewport); UE_LOG(LogTemp, Log, TEXT(\u0026#34;%s\u0026#34;), (bIsFocusedViewport ? TEXT(\u0026#34;FOCUSED\u0026#34;) : TEXT(\u0026#34;NOT FOCUSED\u0026#34;))); } } #endif //UE_EDITOR Cheers!\n","date":"2022-03-05","permalink":"/posts/how-to-check-viewport-is-focused/","section":"Posts","summary":"How To Check Viewport Is Focused","title":"How To Check Viewport Is Focused"},{"content":"","date":"2021-12-12","permalink":"/tags/class/","section":"Tags","summary":"","title":"Class"},{"content":"It\u0026rsquo;s just simple. Just check with this code.\nGetClass()-\u0026gt;IsNative() You can test like this.\nFString Result = GetClass()-\u0026gt;IsNative() ? TEXT(\u0026#34; : NATIVE\u0026#34;) : TEXT(\u0026#34; : BLUEPRINT\u0026#34;); GEngine-\u0026gt;AddOnScreenDebugMessage(-1, 999.f, GetClass()-\u0026gt;IsNative() ? FColor::Yellow : FColor::Cyan, GetName() + Result); ","date":"2021-12-12","permalink":"/posts/how-to-check-class-is-from-native-or-blueprint/","section":"Posts","summary":"How To Check Class Is From Native Or Blueprint","title":"How To Check Class Is From Native Or Blueprint"},{"content":"","date":"2021-12-11","permalink":"/tags/enum/","section":"Tags","summary":"","title":"Enum"},{"content":"Sometimes we want to iterate over enum values.\nIn the Unreal Engine, We already have macros about making rages for UENUM.\nFirst, Let\u0026rsquo;s make a test enum type.\nUENUM(BlueprintType) enum class ETest : uint8 { ZERO, FIRST, SECOND, THIRD, FOURTH, FIFTH }; That looks decent enum type.\nWe also need to print the enum value name for the test.\ntemplate\u0026lt;typename TEnum\u0026gt; static FString EnumToString(const FString\u0026amp; Name, TEnum Value) { const UEnum* EnumPtr = FindObject\u0026lt;UEnum\u0026gt;(ANY_PACKAGE, *Name, true); if (UNLIKELY(!IsValid(EnumPtr))) return FString(\u0026#34;Invalid\u0026#34;); return EnumPtr-\u0026gt;GetNameStringByValue((int32)Value); } Okay, I think we\u0026rsquo;re ready! Let\u0026rsquo;s get into the topic.\nThere are 3 types of enum range macro.\nENUM_RANGE_BY_COUNT # This is a simple one.\nIt makes iterator range from the initial value to counted value.\nIf we declare a range like below, We\u0026rsquo;ll Iterator 3 elements from the initial value.\nENUM_RANGE_BY_COUNT(ETest, 3); Now we can iterate UENUM value with TEnumRange\u0026lt;\u0026gt; like this.\nfor (ETest Iter : TEnumRange\u0026lt;ETest\u0026gt;()) { GEngine-\u0026gt;AddOnScreenDebugMessage(-1, 999.f, FColor::Cyan, EnumToString\u0026lt;ETest\u0026gt;(\u0026#34;ETest\u0026#34;,Iter)); } You can see that we print only 3 elements.\nENUM_RANGE_BY_FIRST_AND_LAST # This version allows us to set the range scope ourselves.\nIf we declare a range like below, We\u0026rsquo;ll Iterator elements that from value to value.\nfrom 2(ETest::SECOND) to 5(ETest::FIFTH)\nENUM_RANGE_BY_FIRST_AND_LAST(ETest, 2, 5); You can see that we print from 2 to 5 value.\nENUM_RANGE_BY_VALUES # This version is quite interesting.\nLet\u0026rsquo;s say we make our enum values non-contiguous like this.\nUENUM(BlueprintType) enum class ETest : uint8 { ZERO = 0, FIRST = 3, SECOND = 5, THIRD = 10, FOURTH = 99, FIFTH = 128 }; We can\u0026rsquo;t use the macro that was explained before. Because this enum is non-contiguous.\nIf we declare macro like below, We\u0026rsquo;ll Iterator non-contiguous enum range with specific individual values.\nENUM_RANGE_BY_VALUES(ETest, ETest::FIRST, ETest::FOURTH); If you want to go deeper # You can find more details on these macro in EnumRange.h\nEngine\\Source\\Runtime\\Core\\Public\\Misc\\EnumRange.h\n","date":"2021-12-11","permalink":"/posts/how-to-iterate-over-uenum/","section":"Posts","summary":"Advanced Use of Unreal Engine Enumerator","title":"How To Iterate Over UENUM"},{"content":" Unreal Summit 2019 이득우 교수님 세션에도 나왔었다 ㅋㅋㅋㅋㅋㅋㅋㅋ 뿌-듯\n","date":"2019-07-03","permalink":"/posts/old-blog/awake-%EB%A5%BC-%EA%B0%9C%EB%B0%9C%ED%95%98%EB%A9%B0-%EA%B3%A0%EB%AF%BC%ED%96%88%EB%8D%98-%EC%96%B8%EB%A6%AC%EC%96%BC-%EC%97%94%EC%A7%84-%EB%B9%8C%EB%93%9C-%ED%83%80%EC%9E%84%EC%9D%84-%EC%A4%84/","section":"Posts","summary":"AWAKE 를 개발하며 고민했던 언리얼 엔진 빌드 타임을 줄이기 위한 시도들 (BUILD TIME KILLER)\u0026quot;","title":"AWAKE 를 개발하며 고민했던 언리얼 엔진 빌드 타임을 줄이기 위한 시도들 (BUILD TIME KILLER)"},{"content":" DISCLAIMER # 현 자료는 Epic Games의 Unreal Engine EVnagelist인 Chris Murphy님의 언리얼 서밋 2019 발표 자료 내용입니다. 모든 내용은 영상을 보며, 작성하였으며, 본인 개인의 공부 목적으로 간단하고 짧게 정리한 내용이라, 부정확한 정보가 존재하니 이점 유념하여 봐주시길 바랍니다.\n상단의 Help-\u0026gt;Console Variables에 들어가보면 에디터에서 사용할 수 있는 Console Command들을 HTML 페이지를 통해 검색해서 볼 수 있다.\n수학을 잘 모르는 개발자나 아트 직군을 위해서 Math Hall 이라는 수학 수식 안내용 맵이 존재한다.\n아트나 기획직군에게 엔지니어 멘토를 붙여주면 블루프린트를 이용한 워크플로에 많은 도움이 된다.\n오소그래픽 뷰포트에서 마우스 휠을 누르고 마우스를 움직이면 거리를 잴 수 있다. markup\nAlt+마우스 휠을 누르면 임시 Pivot을 설정해 물체의 Transform을 변경하기 아주 쉬워진다.\nCtrl_마우스 휠을 누르면서 드레그를 하면 뷰모드를 바꿀 수 있다. 방향마다 가는 뷰모드가 달라진다.\nShift+마우스 드레그를 하면 물체를 바라보고있던 카메라와 함께 움직인다.\nCtrl+마우스 버튼(왼쪽,오른쪽,둘다)을 누르면 물체의 위젯을 직접 잡지 않아도 움직일 수 있다.\nCtrl+\u0026rsquo;(Tilt)를 누면 로컬 좌표계와 월드 좌표계로 전환할 수 있다.\n오른쪽 클릭을 누르고 마우스휠을 올리거나 내리면 움직이는 속도를 바꿀 수 있다.\n떠있는 물체에다 End 키를 누르면 바닥에 붙는다.\n뷰포트 옵션 메뉴의 Layouts 탭에서 뷰포트를 나눌 수 있는 옵션이 있다.\nLandscape Grass Node 에서 지형의 식생 분포나 배치를 도와주는 노드가 있다.\n에디터 값 입력창에서 수식을 통해 값을 계산해 적용할 수있다. ex(1.0/2)를 Location 변수 지정에 사용가능.\nCall in Editor 이벤트 노드를 붙이면 동적으로 에디터 디테일 창에서 버튼을 통해 함수나 로직을 작동시킬 수 있다.\n머티리얼을 통해 Landscape를 만들 수 있다. Draw Material to Render Target 노드를 설정 후, Landscape Inport Heightmap form Render Target 노드를 사용하면 된다.\n물체를 흩어놔야하는 경우 Simulate Physics가 켜져있는 상태로 에디터를 플레이 해서 어지럽힌 후 K키를 누르면 그 위치에 고정되며, 에디터 플레이가 종료되어도 그 자리로 위치가 고정된다.\n콘텐츠 브라우저에서 검색 구문을 통해 더 세세하게 검색할 수 있다.\nAlt+Shift+O 키를 이용해 에셋 검색창을 바로 열 수 있다.\nBlutilities 라는 스크립팅 유틸리티가 있다. (플러그인 기본 비활성화)\n에디터 유틸리티 위젯이 있으며, Editor Widget을 만들어 게임 테스트 등을 위한 툴을 만들 수 있다.\nTick을 유의해 사용하자. 상황에 따라 타임라인, 타이머 등을 가급적 사용하고, 틱이 필요한 상황에서만 틱을 껏다 켜서 사용할 수 있도록 하며, Event Driven System을 만들자. Tick이 필요없는 엑터는 Actor Tick에서 Tick을 끄자, Blueprints 탭에서도 Can Blueprint Tick by Default를 끄도록 하자.\n게임이 잠깐씩 멈추는 것을 로그로 뽑아 볼 수 있다.\nt.HitchFrameTimeThreshold를 설정하면 볼 수 있다.\n콘텐츠 브라우저에서 폴더에 오른쪽 클릭을해서 Set Color를 하면 폴더의 색을 바꿀 수 있다.\n컬러 픽커를 통해 색을 고를 수 있다.\n버츄얼 카메라를 통해 핸드폰의 회전이나 위치를 동기화해서 게임속화면을 볼 수 있다.\n블루프린트 연결 노드를 Ctrl키를 누른뒤 잡으면 지우지 않고도 움직일 수 있다.\n이미 있는 지역변수를 오른쪽 클릭해서 Promote to Variable로 하면 변수로 설정할 수 있다.\n건틀렛(Gauntlet)프레임워크를 사용하면 멀티 플렛폼을 위한 빌드, 테스트 등등을 진행할 수있다.\nProcedural Foliage Tool을 사용해서 폴리지를 더 현실감있게 배치할 수 있다.\nVisualisation Modes를 통해 Deferred Render 버퍼의 모든 것을 볼 수 있다.\n맵 속 오브젝트를 누르고 복사해 메모장 같은 편집기에 불여넣으면 디테일 설정들이 복사되어 나타난다.\n마켓 플레이스에 Free Automotive Materials가 있다. (PBR 머티리얼들)\n마켓 플레이스에 Paragon 에셋들 전부 풀었다.\n오브젝트를 옮길 때, V키를 누르면 버텍스 스냅이 가능하다.\nPivot Painter 2를 쓸 수 있다. (Extra에서 설치해야함)\n모바일용 플러그인들이 존재한다. (사운드 볼륨, 배터리 잔량, 온도, GPS, 등등)\n로보리콜 모드킷 있으니까 함 써봐라 VR게임 만들면서 여러 샘플이나 참고자료를 만들어 두었다.\n로보리콜용 Behavior Tree 보면 공부 많이 될꺼다.\nEnvironmental Query System(EQS)로 맵상의 AI에게 지형에서도 정보를 얻을 수 있게 해준다.\n화면 분할 플레이모드가 있다.\nAnimation Fast Path라는 기능을 사용하면 변수 접근이 최적화되어, 퍼포먼스가 올라간다.\n(프로젝트 세팅에서 Optimize Anim Blueprint Member Variable Access)\nAsset sManagement Framework를 사용하면 에디터나 런타임에서 에셋을 로드하거나 찾을 수 있다. hard reference를 그만 사용할 수 있도록 해줌.\nVR에서는 포워드 렌더러 사용을 고려해봐라. VR은 포워드 렌더러에 최적화 해놨다. 그리고 그냥 게임들도 라이트 많이 없으면 포워드 렌더러 사용해봐라.\nLightweight Rigid Body Simulation이 있다. 캐릭터들의 시뮬레이션이 한 번에 많이 일어날 때 사용해라.\n대규모 월드를 만들 경우 월드 컴포지션 툴을 사용해라.(레벨 스트리밍에서 사용 불가)\n이펙트의 Overdraw를 조심해라. 파티클의 경우 Cutout 모드를 사용하는게 좋다.\n머티리얼 Draw Cost를 조사하라.\nr.rhicmdbpass 1\nr.rhithread.enable 0\nr.showmaterialdrawevents -1\nProfilegpu\n(항상 믿을만 한 것은 아님)\n머티리얼 함수를 레이어로 쓸 수 있다. (RGB에 따라 재질 머티리얼 설정 등등)\n스텐실 버퍼를 사용하면 에셋이 다른 버퍼에서 렌더링 될 수있도록 해준다. (VFX에 유용)\nPixel Depth Offset을 쓰면 오클루전 테스트를 렌더러 안에서 조정할 수 있다.(추가적인 약간의 오버헤드 발생)\nWorld Aligned Material을 만들어 쓰면 base UV를 무시하고 맵상에서 균일한 패턴을 얻을 수 있다. (자세한 건 모름)\nPre-Skinned Local Position/Normal. T-Pose의 위치를 캐시해 매시에 데칼이나 위장 머티리얼을 래핑할 필요없이 사용할 수 있다. (잘 모름)\nSun Position Calculator Plugin 이 있다. 블루프린트 엑터이고, 태양의 위치를 조정할 때 아주 좋다.\nMesh Decal은 간과할 거이 아니다. Masked된 메쉬와 거의 차이가 없다.\n자동 LOD 생성이 가능하다. 필요한 곳에 그룹으로 묶어 사용할 수도 있다.\nSkeletal Mesh도 LOD 생성이 가능하다.\nLow Latency Frame Syncing Mode를 사용하면 인풋 레이턴시를 줄일 수 있다.(잘 모름)\nr.OneFrameThreadLag는 항상 켜져있는 상태이고,\nr.GTSyncType 을 0,1,2 값으로 수정하며 사용한다.\n고해상도 스크린샷 촬영을 에디터 옵션탭에서 사용할 수 있다.\n쉐이더 컴파일이 오래 걸린다면 프로젝트 세팅에서 Shader Permutation을 비활성화 하도록 해보자.\n픽셀은 항상 문제가 되는 것이 아니다. (사진 첨부)\n블루프린트가 Hard Reference 되는 것을 피하라. 블루프린트가 다른 블루프린트를 레퍼런싱 한다면 그 블루프린트들은 모두 메모리에 로드될 것이다. 쌓이다 보면 겉잡을 수 없으니 미리 주의하라. 특히 게임이 느려지지는 않겠으나, 메모리나 로드타임이 오래걸리니 주의하라.\nPlotFunctionOnGraph 노드를 사용하면 현재 구성된 로직이 어떻게 변화하는지 그래프로 확인할 수 있다.\n프로젝트 세팅에서 Small Tool Bar Icons 를 사용하면, 툴바 아이콘들이 작아져 화면을 더 볼 수 있다. (프로같아보임)\n나이아가라 이펙트를 만들 때, 파티클은 Interpolated Spawning을 가능한 비활성화 하라. 오버헤드가 발생하며, 비활성화 하면 더 많은 파티클을 훨씬 적은 오버헤드로 생성 가능하다.\nVR Editor로 레벨 콘텐츠를 배치하거나 수정하거나 할 수 있다.\nAR 셋업용 팁. (사진 첨부)\n60. 자료 # 66. 자료 # 아죠시\u0026hellip; 100개가 아닌데요\u0026hellip;?\n","date":"2019-06-21","permalink":"/posts/old-blog/%EC%96%B8%EB%A6%AC%EC%96%BC-%EB%B2%A0%ED%85%8C%EB%9E%91%EC%9D%98-100%EA%B0%80%EC%A7%80-%ED%8C%81%EA%B3%BC-%ED%8A%B8%EB%A6%AD-%EC%A0%95%EB%A6%AC/","section":"Posts","summary":"언리얼 베테랑의 100가지 팁과 트릭 정리","title":"언리얼 베테랑의 100가지 팁과 트릭 정리"},{"content":"","date":"0001-01-01","permalink":"/topics/","section":"Topics","summary":"","title":"Topics"}]