[{"content":" ","date":"2023-08-13","permalink":"/","section":"","summary":" ","title":""},{"content":"","date":"2023-08-13","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"2023-08-13","permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++"},{"content":"","date":"2023-08-13","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"2023-08-13","permalink":"/series/game-server-development/","section":"Series","summary":"","title":"Game Server Development"},{"content":" Material # [C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버\n아래 글의 #Dead-Lock 섹션에 기본적인 문제를 설명해 두었었다. 먼저 읽어본다면 지금 글을 이해하는데 도움이 될 것이다.\nGame Server Development #3 : Lock 2023-08-12\u0026middot; 0 \u0026middot; 0 BBAGWANG Korean Post Programming C\u0026#43;\u0026#43; Server Thread Lock 4 Necessary Conditions for Dead Lock # Dead Lock 이 발생하려면 다음의 4 가지 조건이 동시에 만족되어야 한다.\n상호 배제 (Mutual Exclusion) # 한 번에 한 프로세스만 공유 자원을 사용할 수 있다.\n점유 및 대기 (Hold and Wait) # 프로세스가 최소한 하나의 자원을 점유하고 있으면서, 다른 프로세스에 의해 점유 중인 자원을 추가로 기다린다.\n비선점 (No Preemption) # 자원을 점유한 프로세스는 그 자원을 스스로만 방출할 수 있다.\n환형 대기 (Circular Wait) # 두 개 이상의 프로세스나 스레드가 서로를 기다리는 사이클이 형성한다.\nProblem Example # 아직 데드락을 탐지하는 방법은 배우지 않았고, 추후 작성할 Dead Lock Detection 글에서 문제 해결 방법을 이어 설명할 예정이다.\n이번 글에서는 데드락이 일어나는 또 다른 경우와 그 해결법에 대해 설명한다.\nAccount 라는 정보를 관린하는 Account Manager 클래스가 존재하고, User 라는 정보를 관리하는 User Manager 가 존재한다고 가정해보자.\n~Manager 들은 Singleton 으로 구현되어 있으며, MMORPG 게임의 유저와 계정 정보를 관리하는 클래스이다.\n코드로 작성해보면 다음과 같다.\nAccount Manager\nclass Account { //TEMP } class AccountManager { public: static AccountManager* Instance() { static AccountManager instance; return \u0026amp;instance; } Account* GetAccount(int32 id) { return nullptr; } void ProcessLogin(); private: mutex _mutex; //map\u0026lt;int32, Account*\u0026gt; _accounts; } User Manager\nclass User { //TEMP } public: static UserManager* Instance() { static UserManager instance; return \u0026amp;instance; } User* GetUser(int32 id) { return nullptr; } void ProcessSave(); private: mutex _mutex; //map\u0026lt;int32, User*\u0026gt; _users; } 이처럼 각각의 매니저는 mutex 를 갖고있고, ProcessLogin 과 ProcessSave 라는 기능이 있다.\n여기서 AccountManager 의 ProcessLogin 함수에 다음과 같은 로직이 구현된다.\nvoid AccountManager::ProcessLogin() { //AccountManager 의 mutex 획득 시도 std::lock_guard\u0026lt;mutex\u0026gt; guard(_mutex); //UserManager 의 mutex 획득 시도 User* user = UserManager::Instance()-\u0026gt;GetUser(100); //Something... } AccountManager 의 mutex 를 잡은 다음에, UserManager 의 mutex 또한 획득하려 한다.\n그런데 이제 필요에 의해 UserManager 의 ProcessSave 또한 다음과 같은 로직이 구현된다.\nvoid UserManager::ProcessSave() { //UserManager 의 mutex 획득 시도 std::lock_guard\u0026lt;mutex\u0026gt; guard(_mutex); //AccountManager 의 mutex 획득 시도 User* user = AccountManager::Instance()-\u0026gt;GetAccount(100); //Something... } UserManager 의 mutex 를 잡은 다음에, AccountManager 의 mutex 를 획득하려 한다.\n이제 다음과 같이 여러번 호출하는 상황을 만들어 문제가 없는지 확인해보자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026#34;AccountManager.h\u0026#34; #include \u0026#34;UserManager.h\u0026#34; void Func1() { for(int i = 0; i \u0026lt; 1000; ++i) { UserManager::Instance()-\u0026gt;ProcessSave(); }\t} void Func2() { for(int i = 0; i \u0026lt; 1000; ++i) { AccountManager::Instance()-\u0026gt;ProcessLogin(); } } int main() { std::thread t1(Func1); std::thread t2(Func2); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; \u0026#34;Jobs Done\u0026#34; \u0026lt;\u0026lt; std::endl; } 실행해보니 Jobs Done 이 출력되지 않는다.\nUserManager 는 AccountManager 의 락을 획득하려 한다.\nAccountManager 는 UserManager 의 락을 획득하려 한다.\n서로가 서로의 락이 풀리기를 기다리는 교착 상태에 빠져버렸다.\nSolution # 위와 같은 상황은 락을 잡는 순서를 맞춰주면 해결할 수 있다.\n일단 UserManager 의 ProcessSave 가 다음과 같이 바뀐다면 해결된다.\nvoid UserManager::ProcessSave() { //AccountManager 의 mutex 획득 시도 User* user = AccountManager::Instance()-\u0026gt;GetAccount(100); //UserManager 의 mutex 획득 시도 std::lock_guard\u0026lt;mutex\u0026gt; guard(_mutex); //Something... } AccountManager 의 ProcessLogin 과 락을 잡는 순서를 맞춰주면 되는 것이다.\n반대로 AccountManager 가 UserManager 의 ProcessSave 와 동일한 락 순서를 만들어도 된다.\n하지만, 이건 이렇게 간단한 상황일때나 가능한 이야기고, 사용하는 스레드와 뮤텍스가 많아지면 일일히 순서를 관리하는 것은 너무 어렵다.\nConclusion # 락을 거는 순서에 유의하여 락을 걸어야 한다.\n추후 락을 거는 순서에 싸이클이 발생하는지 탐지하는 알고리즘을 이용하여 이러한 문제 상황을 쉽게 확인할 수 있도록 해야한다.\nstd::lock # std::lock은 C++11에서 도입된 기능으로, 여러 개의 std::mutex를 Dead Lock 없이 한번에 잠그기 위해 사용한다.\nstd::lock은 여러 개의 std::mutex 객체를 인자로 받아, 그 중 어떤 것도 잠기지 않은 상태에서 모든 뮤텍스를 한 번에 잠근다.\n만약 일부 뮤텍스가 이미 잠겼다면, std::lock 은 필요한 모든 뮤텍스가 풀릴 때까지 기다린 다음, 그것들을 한번에 잠근다.\n한 번에 잠그기 때문에 교착 상태가 일어날 가능성이 줄어든다.\nstd::mutex m1, m2; std::lock(m1, m2); // 두 뮤텍스를 한번에 잠금 (잠기는 순서는 상관없음) std::adpot_lock # std::lock 을 이용해 한 번에 여러개의 mutex 를 획득 했다고 치자.\nstd::lock 공유 자원을 건드는 일을 마친 후 다시 락을 반환해 주어야 한다.\n이미 std::lock_guard 를 통해 RAII 패턴으로 함수를 벗어나면 락을 풀어줄 수 있는 방법이 있다.\n하지만, std::lock_guard 는 인자로 넘어온 mutex 를 즉시 잠구려고 시도한다.\n이미 잠긴 mutex 를 다시 잠구려고 시도하면 또다시 Dead Lock 이 발생한다.\n잠긴 mutex 를 풀어주기 전까진 다시 잠굴 수 없기 때문이다. (이를 위해 std::recursive_lock 이 있긴 한데 지금은 몰라도 된다.)\n아래의 코드와 같은 상황이라고 보면 된다.\n#include \u0026lt;thread\u0026gt; #include \u0026lt;mutex\u0026gt; std::mutex mtx; void DoubleLock() { mtx.lock(); mtx.lock(); mtx.unlock(); mtx.unlock(); } int main() { std::thread t1(DoubleLock); t1.join(); return 0; } 이럴때 std::adopt_lock 을 사용하면 문제를 해결할 수 있다.\nstd::adopt_lock 은 인자로 넘어온 뮤텍스가 이미 잠겨 있음을 인지하고, 추가로 잠그지 말고 나중에 소멸될 때 락을 풀어주기만 해라 라는 의미이다.\nstd::mutex mtx1, mtx2; void MultiMutex() { std::lock(mtx1, mtx2); // mtx1과 mtx2를 동시에 잠근다. // 아래의 lock_guard는 mtx1과 mtx2가 이미 잠겼음을 \u0026#34;인지\u0026#34;하고, 추가로 잠그려고 시도하지 않는다. std::lock_guard\u0026lt;std::mutex\u0026gt; lock1(mtx1, std::adopt_lock); std::lock_guard\u0026lt;std::mutex\u0026gt; lock2(mtx2, std::adopt_lock); // ... 임의의 (공유 자원에 대한) 작업 ... // lock1과 lock2가 소멸되면 mtx1과 mtx2는 자동으로 해제된다. } ","date":"2023-08-13","permalink":"/posts/game-server-development/4-deadlock/","section":"Posts","summary":"Dead Lock","title":"Game Server Development #4 : Dead Lock"},{"content":"","date":"2023-08-13","permalink":"/categories/korean-post/","section":"Categories","summary":"","title":"Korean Post"},{"content":"","date":"2023-08-13","permalink":"/tags/lock/","section":"Tags","summary":"","title":"Lock"},{"content":"","date":"2023-08-13","permalink":"/categories/programming/","section":"Categories","summary":"","title":"Programming"},{"content":"","date":"2023-08-13","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"2023-08-13","permalink":"/tags/server/","section":"Tags","summary":"","title":"Server"},{"content":"","date":"2023-08-13","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"2023-08-13","permalink":"/tags/thread/","section":"Tags","summary":"","title":"Thread"},{"content":" Material # [C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버\nWhat is Lock # Lock(락) 은 동시에 여러 스레드에 의해 접근될 수 있는 데이터나 자원인 공유 자원의 동시 접근을 제어하고자 할 때 사용한다.\n락을 쉽게 이해하는 방법은, 실생활에서 사용하는 자물쇠를 생각해보면 된다.\n예를 들어, 두 사람이 한 개의 화장실을 사용하고 싶을 때, 먼저 도착한 사람이 화장실을 사용하게 되고, 그 사람이 사용하는 동안 다른 사람은 기다려야 한다.\n이때 화장실에 자물쇠를 걸어 다른 사람이 사용하지 못하게 한다고 생각하면 된다.\n비슷하게, 한 스레드가 공유 자원에 접근하기 위해 락을 획득(잠금)하면, 그 스레드만 해당 자원에 접근할 수 있고, 다른 스레드들은 그 락이 해제(잠금 해제)될 때까지 기다려야 한다.\n이렇게 락을 사용하면 여러 스레드가 동시에 같은 자원에 접근하는 것을 막아 데이터의 무결성을 유지할 수 있다.\nProblem # 필요성을 느끼기 위해 문제가 되는 상황을 먼저 확인 해보자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; std::vector\u0026lt;int\u0026gt; v; void Push() { for (int i = 0; i \u0026lt; 1\u0026#39;0000; ++i) { v.push_back(i); } } int main() { std::thread t1(Push); std::thread t2(Push); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; std::endl; return 0; } 가장 먼저 이 코드는 런타임 에러. 즉, 크래시가 발생한다.\n이유는 다음과 같다.\nv 의 값이 채워지며, capacity 를 넘는 데이터 삽입 요청이 발생하는 경우, v 의 capacity 를 늘리기 위해 메모리를 재할당한다.\nt1 스레드가 요청한 삽입을 처리하기 위해 v 의 capacity 를 늘리기 위해 메모리를 재할당하고 있는 도중 t2 스레드가 v 에 데이터를 삽입한다면, t2 스레드가 접근하려는 메모리는 해제된 메모리이기 때문에, 재할당한 메모리에 접근할 수 없게 되어 런타임 에러가 발생한다.\n또 한편으로는 동시에 두 스레드 모두가 재할당을 요청하는 문제도 생길수도 있다.\n그럼 만약 v 가 재할당이 일어나지 않았다면 문제가 없을까?\n결론부터 말하자면, 그렇지 않다.\n두 스레드가 동시에 v 의 size 를 확인하고, 그 값에 1을 더한 값을 v 에 추가하려고 할 것이다.\n이때, 두 스레드가 동시에 size 를 확인하면, 서로 같은 값을 반환할 것이다.\n그 상태에서 두 스레드가 size 에 1을 더한 값을 v 에 추가하려고 할 것이다.\n이러면 v 에는 1개의 값만 추가되었을 것이다.\n2 가지의 다른 문제가 있지만 결국 이러한 문제를 Race Condition(경쟁 상태) 라고 한다.\nMutual Exclusion # Lock 을 사용하여 문제를 해결해보자.\nC++ 에서 락을 사용하기 위해서는 mutex 라는 클래스를 사용한다.\nmutex 는 Mutual Exclusion(상호 배제) 라는 의미를 가지고 있다.\nmutex 는 lock 과 unlock 이라는 직관적인 함수를 통해 사용할 수 있다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;mutex\u0026gt; std::vector\u0026lt;int\u0026gt; v; std::mutex m; void Push() { for (int i = 0; i \u0026lt; 1\u0026#39;0000; ++i) { m.lock(); v.push_back(i); m.unlock(); } } int main() { std::thread t1(Push); std::thread t2(Push); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; v.size() \u0026lt;\u0026lt; std::endl; return 0; } \u0026lt;mutex\u0026gt; 헤더를 추가하고, std::mutex 객체를 생성한다. 경쟁이 발생할 위험이 있는 부분에 lock 함수를 호출하여 락을 획득한다. 락을 획득한 후, 공유 자원에 접근한다. 만약 락을 획득하지 못했다면, 그 스레드는 접근하려는 락이 해제될 때까지 대기한다. 공유 자원에 접근이 끝나면 unlock 함수를 호출하여 락을 해제한다. 더 쉽게 보면, 자물쇠(mutex) 를 잠그고 (lock) 사용하고, 사용이 끝나면 자물쇠를 푼다 (unlock) 는 개념이다.\nmutex의 lock 안의 구간은 싱글 스레드로 동작하는 것과 같다. 단 하나의 스레드의 접근만 허용하기 때문이다.\nDead Lock # 락을 잠궈두고 unlock 을 하지 않는다면, 그 락은 영원히 해제되지 않는다.\n그리고 그 락이 풀리길 기다리는 다른 스레드들은 영원히 대기하는 상태에 빠지고 만다.\n이와 같이 비정상적인 락의 상황 때문에 스레드들이 무한정 대기하는 상황을 Dead Lock(데드락) 이라고 한다.\nDead Lock 은 두 개 이상의 프로세스나 스레드가 서로의 자원을 기다리며 영원히 진행되지 못하는 상태를 의미한다.\n다음과 같은 코드를 보자.\n#include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;mutex\u0026gt; std::vector\u0026lt;int\u0026gt; v; std::mutex m; void Push() { for (int i = 0; i \u0026lt; 1\u0026#39;0000; ++i) { m.lock(); v.push_back(i); if (i == 5000) break; m.unlock(); } } 개발을 하다보면 위처럼 다양한 분기와 처리를 진행하게 된다.\n이럴때 실수로 위와같이 i 가 5000 에 도달할 경우, 락을 해제하지 않고 함수를 빠져 나가는 실수를 할 수 있다.\n조건문 안에 m.unlock() 을 넣어 해결할 수도 있지만, 만약 저 코드가 다양한 내용을 처리하는 100줄 이상의 함수였다면, 그 조건문을 찾기도 힘들고, 또 다른 조건문을 추가할 때마다 unlock 을 추가해야 한다.\n이는 매우 귀찮고, 번거로우며, 실수하기 딱 좋은 상황이 된다.\n위처럼 단순한 예는 그나마 금방 찾을 수 있지만, 실제로는 더 복잡한 Dead Lock 상황이 발생할 수 있으므로 조심해야한다.\nLock Guard # 위와 같은 Dead Lock 상황을 미연에 방지하기 위해 std::lock_guard 라는 클래스를 사용할 수 있다.\nstd::lock_guard 는 mutex 를 생성자에서 획득하고, 소멸자에서 해제하는 클래스이다.\n이렇게 하면 스코프를 벗어나는 순간 mutex 가 해제되기 때문에, unlock 을 신경쓰지 않아도 된다.\n이러한 방식을 RAII(Resource Acquisition Is Initialization) 라고 한다.\nstd::lock_guard 를 사용하면 다음과 같이 코드를 작성할 수 있다.\n#include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;mutex\u0026gt; std::vector\u0026lt;int\u0026gt; v; std::mutex m; void Push() { for (int i = 0; i \u0026lt; 1\u0026#39;0000; ++i) { std::lock_guard\u0026lt;std::mutex\u0026gt; lockGuard(m); v.push_back(i); if (i == 5000) break; } } 명시적인 unlock 을 신경쓸 필요가 없게 되어 더 안전한 코드를 작성할 수 있다.\nRAII 는 꽤나 간단한 개념이므로, 아래와 같이 직접 Wrapper 를 만들어 Lock Guard 를 만들어 쓸 수도 있다.\n#include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;mutex\u0026gt; std::vector\u0026lt;int\u0026gt; v; std::mutex m; template\u0026lt;typename T\u0026gt; class LockGuard { public: LockGuard(T\u0026amp; mutex) : m_mutex(mutex) { m_mutex.lock(); } ~LockGuard() { m_mutex.unlock(); } private: T* m_mutex; } void Push() { for (int i = 0; i \u0026lt; 1\u0026#39;0000; ++i) { LockGuard\u0026lt;std::mutex\u0026gt; lockGuard(m); v.push_back(i); if (i == 5000) break; } } Unique Lock # 위에서 보았던 std::lock_guard 는 mutex 를 생성자에서 획득하고, 소멸자에서 해제하는 클래스이다.\n이러한 방식은 생성하자마자 mutex 를 획득하기 때문에 lock 을 거는 시점을 제어할 수 없다는 단점이 있다.\n이러한 점을 보완하기 위해 std::unique_lock 을 사용할 수 있다.\nstd::unique_lock 은 lock 함수를 호출하는 순간에 mutex 를 획득하려 하기 때문에 시점을 제어할 수 있다.\n#include \u0026lt;thread\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;mutex\u0026gt; std::vector\u0026lt;int\u0026gt; v; std::mutex m; void Push() { for (int i = 0; i \u0026lt; 1\u0026#39;0000; ++i) { std::unique_lock\u0026lt;std::mutex\u0026gt; uniqueLock(m, std::defer_lock); if(i == 0) continue; uniqueLock.lock(); v.push_back(i); if (i == 5000) break; } } Lock Guard vs Unique Lock # std::lock_guard 와 std::unique_lock 의 차이점은 다음과 같다.\nstd::lock_guard\n간단하고 빠른 mutex 락을 위한 클래스이다.\n객체를 생성할 때 mutex가 자동으로 잠기고, 객체가 소멸될 때 자동으로 잠금이 해제된다.\n경량 클래스이며, 별도의 조작(잠금 해제/재잠금)이 필요 없을 때 사용하는 것이 좋다.\nstd::unique_lock\nstd::lock_guard 보다 더 많은 유연성을 제공합니다.\nstd::unique_lock을 사용하면 임의의 위치에서 수동으로 mutex 를 잠글 수 있다.\n더 유연하기 때문에 기능을 위한 구현이 추가되어, std::lock_guard 보다는 조금 더 무겁고 느린 구현이다.\n","date":"2023-08-12","permalink":"/posts/game-server-development/3-lock/","section":"Posts","summary":"Lock","title":"Game Server Development #3 : Lock"},{"content":"","date":"2023-08-11","permalink":"/tags/atomic/","section":"Tags","summary":"","title":"Atomic"},{"content":" Material # [C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버\nRace Condition # 먼저 아래의 코드를 보자.\n#include \u0026lt;iostream\u0026gt; int sum = 0; void Add() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { sum++; } } void Sub() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { sum++; } } int main() { Add(); Sub(); std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 이 코드의 결과 값은 0 이다.\n스레드를 이용해도 동일한지 확인 해보자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; int sum = 0; void Add() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { sum++; } } void Sub() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { sum--; } } int main() { std::thread t1(Add); std::thread t2(Sub); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 이 코드의 결과 값은 0 이 아니다.\n이유를 알아보자\nAdd 함수에서 일어나는 sum++ 을 디스어셈블리를 통해 본다면 다음과 같은 CPU 인스트럭션이 실행된다.\n00007FF64BAC2685 mov eax,dword ptr [sum (07FF64BAD0444h)] 00007FF64BAC268B inc eax 00007FF64BAC268D mov dword ptr [sum (07FF64BAD0444h)],eax 3줄의 어셈블리 코드가 실행되는데, 해석해보면 다음과 같다.\nsum 의 값을 eax 레지스터에 저장한다. eax 레지스터의 값을 1 증가시킨다. eax 레지스터의 값을 다시 sum 에 저장한다. (Sub 함수에서도 값을 감소시키는 것만 다를 뿐, 동일한 과정을 거친다.)\n위 내용을 C++ 코드로 표현하면 다음과 같다.\nint eax = sum; eax = eax + 1; sum = eax; 우리가 보는 한 줄의 C++ 코드는 컴파일을 거친 후, CPU 에서 실행되기 위한 3 줄의 어셈블리 코드로 변환되었다.\nCPU 에서는 메모리에서 어떤 값을 레지스터에 꺼내오고, 연산을 수행하고, 다시 메모리에 값을 저장하는 과정들을 각각 진행시키기 때문이다.\n이제 다시 본론으로 돌아와서 문제가 되는 상황을 보자.\nt1 과 t2 스레드는 동시에 실행되기 때문에 전역 변수 sum 을 동시에 접근하게 된다. 그리고 어떤 스레드가 먼저 실행될지, 언제 실행될지도 알 수 없다.\nt1 스레드에서 eax 레지스터에 sum 의 값을 저장하고 eax 의 값을 올린다. (eax = 1, sum = 0) t2 스레드에서 eax 레지스터에 sum 의 값을 저장하고 eax 의 값을 내린다. (eax = -1, sum = 0) t1 스레드에서 Context Switch 가 발생하여, eax 의 값을 sum 에 넣는 명령을 실행하기 직전인 상태로 대기한다. t2 스레드는 eax 의 값을 sum 에 넣는 명령을 실행한다. (eax = -1, sum = -1) t1 스레드가 다시 CPU Time 을 획득하여, eax 의 값을 sum 에 넣는다. (eax = 1, sum = 1) sum 의 값은 0 이 아닌 1 이 된다. 결국 t2 의 연산이 무시되고, t1 의 연산만 반영된 것이다.\n이처럼 여러 스레드가 공유 자원을 동시에 변경할 때, 명령 순서에 따라 결과 값이 의도와 달라질 수 있는 상태를 경쟁 상태 (Race Condition) 라고 한다.\nSynchronization # 위와 같은 경쟁 상태를 해결하기 위해선, 공유 자원에 대한 접근 순서를 보장 해야 한다.\n접근 순서를 보장하는 것을 동기화 (Synchronization) 라고 한다.\n동기화에는 Mutex, Condition Variable, Atomic Operation 등등 여러가지 기법들이 존재한다.\n그 중에서도 가장 직관적인 Atomic Operation 을 이용해 지금의 경쟁 상태를 해결해보자.\nAtomic Operation # Atom(원자) 는 더 이상 쪼갤 수 없는 단위를 의미한다.\n비슷한 맥락으로 Atomic Operation(원자적 연산) 은 다른 스레드 간섭 없이, 연산이 한 번에 완료됨을 보장하는 연산 을 의미한다.\n조금 더 쉽게 말해보면 전부 실행이 되거나, 전혀 실행되지 않거나 둘 중 하나의 상태만 가능한 All or Nothing 연산이라고 할 수 있다.\n즉, 연산이 완료되기 전까지는 다른 스레드가 접근할 수 없다. (연산을 쪼갤 수 없다)\n위에서 문제가 되었던 sum++ 가 한 번에 이뤄짐을 보장해 주었다면, Race Condition 은 발생하지 않았을 것이다.\n그럼 아까의 문제 상황을 해결하기 위해 코드를 원자적 연산으로 바꿔보자.\nC++ 에서는 표준으로 원자적 연산을 지원한다. atomic 헤더를 추가하고, std::atomic 템플릿을 이용하면 된다.\nsum 의 타입을 atomic\u0026lt;int\u0026gt; 로 변경해보자.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;atomic\u0026gt; std::atomic\u0026lt;int\u0026gt; sum = 0; void Add() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { sum.fetch_add(1); } } void Sub() { for (int i = 0; i \u0026lt; 100\u0026#39;0000; ++i) { sum.fetch_add(-1); } } int main() { std::thread t1(Add); std::thread t2(Sub); t1.join(); t2.join(); std::cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 이 코드의 결과 값은 0 이다.\nAdd 함수의 fetch_add 함수는 원자적으로 동작하기 때문에, sum 의 값을 읽어오고, 1 을 더한 후, 다시 sum 에 저장하는 과정이 한 번에 이뤄진다.\n만약, Add 함수의 sum 변수에 대한 연산이 진행중인 상태에서 Sub 함수가 sum 변수에 접근하려고 하면, Sub 함수는 Add 함수의 연산이 완료될 때까지 대기하게 된다.\n이렇게 대기 시키는 것은 CPU 명령으로 구현되어 있어서, CPU 단에서 원자성을 보장해준다.\n그럼 Atomic 을 모든 곳에 때려 박으면 모든 문제가 해결되는 것일까?\n아쉽게도 그렇지 않다.\nAtomic 은 퍼포먼스를 떨어뜨리는 요소이기 때문에, 필요한 부분에만 사용해야 한다.\n","date":"2023-08-11","permalink":"/posts/game-server-development/2-atomic/","section":"Posts","summary":"Race Condtion, Atomic","title":"Game Server Development #2 : Race Condtion, Atomic"},{"content":" Material # [C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버\nIntroduction # 서버 프로그래밍은 식당을 운영하는 것과 비슷하다.\n식당 : 프로세스 (그림판, 메모장, 게임 서버 등등)\n직원 : 스레드\n영혼 : CPU 코어\n식당에는 주방, 서빙, 청소 등을 담당하는 직원들이 있고, 각각의 직원들은 자신의 역할을 혼자서 또는 여럿이서 수행한다.\n현실과는 살짝 다른 부분이 있다면, 식당 관리자(운영체제) 가 존재하고, 영혼이 직원에게 들어가 있을 때(CPU Time 을 가졌을 때) 만 일을 한다고 보면 된다.\n어떤 식당을 운영하느냐에 따라 직원의 수가 달라지고, 직원의 역할이 달라진다.\n간단한 음식을 파는 가게라면 혼자서도 운영할 수 있다.\n게임 서버라면 단일 스레드로도 충분할 수 있다.\n큰 식당은 혼자서 감당할 수 없다. 여러 직원들이 각자의 역할을 수행하며 식당을 운영해야 한다.\n같은 맥락으로, MMO 같은 대규모 인원이 접속하여 다량의 데이터와 입력을 처리해야하는 경우, 멀티 스레드 구조를 사용하는 것이 필수적이다.\n이제 스레드를 사용하여 멀티 스레드 프로그래밍에 대해 알아보자.\nThread # 스레드는 프로세스 내에서 실행되는 흐름의 단위이다.\n프로세스는 최소 하나의 스레드를 가지고 있다.\n스레드는 프로세스 내의 Code, Data, Heap 메모리를 공유한다.\nStack 은 각각의 스레드에 따로 존재한다.\n사진으로 보면 아래와 같다.\nBasic Thread Usage # C++ 에서 스레드를 사용하는 기본적인 방법은 아래와 같다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; void HelloThread() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello Thread\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::thread t(HelloThread); t.join(); return 0; } 위 코드의 결과는 다음과 같다.\nHello Thread thread 헤더를 include 하고, std::thread 를 사용하여 스레드를 생성한다.\nstd::thread 생성자의 인자로 함수를 넘겨주면, 해당 함수를 새로운 스레드로 실행한다.\njoin 을 호출하여 스레드가 종료될 때까지 기다린다.\nPostpone Thread Execution # 스레드를 생성하고 곧바로 사용하는 방법도 있지만, 아래와 같이 생성만 하고 나중에 사용할 수도 있다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; void HelloThread() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello Thread\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { // thread 객체만 생성. 실행은 하지 않음. std::thread t; // 나중에 실행 t = std::thread(HelloThread); t.join(); return 0; } Passing Arguments # 스레드가 실행할 함수에 대한 인자를 넘겨주는 방법은 아래와 같다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; void HelloThread(int n) { std::cout \u0026lt;\u0026lt; \u0026#34;Hello Thread #\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; std::endl; } int main() { std::thread t(HelloThread, 1); t.join(); return 0; } 위 코드의 결과는 다음과 같다.\nHello Thread #1 Thread ID # 스레드는 각각 고유한 ID 를 가지고 있다.\nget_id 함수를 사용하여 스레드의 ID 를 얻을 수 있다.\n이 ID 를 사용하여 스레드를 구분할 수 있다.\n발급된 ID 는 다른 스레드와 겹치지 않음을 보장하며, 랜덤하게 지정된다.\nID 는 스레드가 실행되고 있지 않은 경우 0 을 반환한다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; void HelloThread() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello Thread\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::thread t = std::thread(HelloThread); std::cout \u0026lt;\u0026lt; t.get_id() \u0026lt;\u0026lt; std::endl; t.join(); std::cout \u0026lt;\u0026lt; t.get_id() \u0026lt;\u0026lt; std::endl; return 0; } 위 코드의 결과는 다음과 같다.\n29836 Hello Thread 0 스레드가 종료되기 전에는 29836 이라는 ID 를 가지고 있었다.\n스레드가 join 을 넘어 종료된 이후, 다시 ID 를 얻어오면 0 이 반환된다.\nJoinable # 스레드는 현재 사용되고 있는지에 대한 체크를 위해 joinable 함수를 제공한다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; void HelloThread() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello Thread\u0026#34; \u0026lt;\u0026lt; std::endl; } int main() { std::thread t = std::thread(HelloThread); std::cout \u0026lt;\u0026lt; t.joinable() \u0026lt;\u0026lt; std::endl; t.join(); std::cout \u0026lt;\u0026lt; t.joinable() \u0026lt;\u0026lt; std::endl; return 0; } 위 코드의 결과는 다음과 같다.\n1 Hello Thread 0 joinable 함수는 구체적으로 *this 의 get_id 의 반환값이 std:🧵:id()(기본값) 와 다른지 체크한다.\nget_id() != std:🧵:id() 따라서 비활성 상태의 스레드는 joinable 하지 않다.\n스레드가 실행을 완료했지만, 아직 join 되지 않은 스레드는 여전히 활성 상태로써 실행되고 있는 스레드로 간주되므로 joinable 하다.\nHardware Concurrency # 스레드를 생성할 때, hardware_concurrency 함수를 사용하여 현재 시스템에서 지원하는 최대 스레드 개수의 hint 를 얻을 수 있다.\n이 값은 hint 로써 제공되며, 100% 신뢰해서는 안된다.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; int main() { unsigned int n = std:🧵:hardware_concurrency(); std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; std::endl; return 0; } 현재 사용중인 Ryzen 3700X CPU 는 8 코어 16 스레드 CPU 이며, 위 코드의 결과는 다음과 같다.\n16 논리 스레드의 갯수를 반환해준다고 보면 된다.\n","date":"2023-08-08","permalink":"/posts/game-server-development/1-thread/","section":"Posts","summary":"Introduction \u0026amp; Thread","title":"Game Server Development #1 : Introduction, Thread"},{"content":"I have been working in the game industry since 2019. As a game programmer, my main goals are fast and accurate implementation of requested game content, understanding the specific needs of developers from different fields and collaborating with them to deliver great game content.\nI prefer an environment where I can experience success and failure faster, learn faster, and have a greater overall impact.\nI\u0026rsquo;m currently focused on improving my skills. I\u0026rsquo;m trying to write about my experiences, topics I\u0026rsquo;m currently interested in, or things I\u0026rsquo;m learning, and I\u0026rsquo;d love to get your feedback on that. I also want to help other programmers or people who want to get into game development.\nFeel free to reach out.\nExperience Company Link Role Project Genre Dates Location PUBG STUDIO Gameplay Programmer PUBG: Battlegrounds Battle Royale 2022 - Present Seoul, KR KRAFTON Gameplay Programmer Project D Soul Like\nAction Adventure\nRPG 2021 - 2022 Seoul, KR EVR STUDIO Client Programmer Project TH TPS Action Adventure 2019 - 2021 Seoul, KR Education School Link Degree Date ChungKang College of Cultural Industries Intensified course completion of major 2020 Game Contents 2017-2019 Project Logo Title Description Link Lua Tonic Unreal Engine ❤️ Lua Github Project V Korean Dark Soul UE DualSense DualSense Controller Support for\nUnreal Engine Github SoyCrab Physics Engine Game Physics Engine Development Github AWAKE Graduational Project Youtube ","date":"2022-06-13","permalink":"/about/","section":"","summary":"I have been working in the game industry since 2019. As a game programmer, my main goals are fast and accurate implementation of requested game content, understanding the specific needs of developers from different fields and collaborating with them to deliver great game content.","title":"About"},{"content":"I have been working in the game industry since 2019. As a game programmer, my main goals are fast and accurate implementation of requested game content, understanding the specific needs of developers from different fields and collaborating with them to deliver great game content.\nI prefer an environment where I can experience success and failure faster, learn faster, and have a greater overall impact.\nI\u0026rsquo;m currently focused on improving my skills. I\u0026rsquo;m trying to write about my experiences, topics I\u0026rsquo;m currently interested in, or things I\u0026rsquo;m learning, and I\u0026rsquo;d love to get your feedback on that. I also want to help other programmers or people who want to get into game development.\nFeel free to reach out.\nExperience Company Link Role Dates Location PUBG STUDIO Gameplay Programmer 2022.01.03 - Present Hybrid Seoul, KR KRAFTON Gameplay Programmer 2021 - 2022 Seoul, KR EVR STUDIO Client Programmer 2019.07.29 - 2020.12.31 Seoul, KR Education School Link Degree Date ChungKang College of Cultural Industries Intensified course completion of major 2020 Game Contents 2017-2019 Project Logo Title Description Link Lua Tonic Unreal Engine ❤️ Lua Github Project V Korean Dark Soul UE DualSense DualSense Controller Support for\nUnreal Engine Github SoyCrab Physics Engine Game Physics Engine Development Github AWAKE Graduational Project Youtube ","date":"2022-06-13","permalink":"/authors/bbagwang/","section":"Authors","summary":"I have been working in the game industry since 2019. As a game programmer, my main goals are fast and accurate implementation of requested game content, understanding the specific needs of developers from different fields and collaborating with them to deliver great game content.","title":"BBAGWANG"},{"content":"","date":"2022-06-13","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"2022-04-23","permalink":"/tags/network/","section":"Tags","summary":"","title":"Network"},{"content":"","date":"2022-04-23","permalink":"/tags/optimize/","section":"Tags","summary":"","title":"Optimize"},{"content":"Unreal Engine 5 가 정식 출시하며 같이 뿌린 Lyra Shooter Project 를 개인적으로 분석하던중 예전부터 듣기만했던 Quantization 에 대해 알아볼 기회가 있어 정리해본다.\nLyra 프로젝트에서는 캐릭터의 Acceleration 관련 변수들을 업데이트하여 Character Movement에 계산시켜 이동을 동기화 시킬때 다음과 같은 구조체를 사용한다.\n/** * FLyraReplicatedAcceleration: Compressed representation of acceleration */ USTRUCT() struct FLyraReplicatedAcceleration { GENERATED_BODY() UPROPERTY() uint8 AccelXYRadians = 0; // Direction of XY accel component, quantized to represent [0, 2*pi] UPROPERTY() uint8 AccelXYMagnitude = 0; //Accel rate of XY component, quantized to represent [0, MaxAcceleration] UPROPERTY() int8 AccelZ = 0; // Raw Z accel rate component, quantized to represent [-MaxAcceleration, MaxAcceleration] }; 여기에서 Quantized to represent 라는 말이 나온다.\n1바이트 정수형 변수들에다 가속에 대한 각도, 크기, 수직값에 대한 정보를 기입하는데 이건 어떻게 넣어주는지 확인해봤다.\nvoid ALyraCharacter::PreReplication(IRepChangedPropertyTracker\u0026amp; ChangedPropertyTracker) { Super::PreReplication(ChangedPropertyTracker); if (UCharacterMovementComponent* MovementComponent = GetCharacterMovement()) { // Compress Acceleration: XY components as direction + magnitude, Z component as direct value const double MaxAccel = MovementComponent-\u0026gt;MaxAcceleration; const FVector CurrentAccel = MovementComponent-\u0026gt;GetCurrentAcceleration(); double AccelXYRadians, AccelXYMagnitude; FMath::CartesianToPolar(CurrentAccel.X, CurrentAccel.Y, AccelXYMagnitude, AccelXYRadians); ReplicatedAcceleration.AccelXYRadians = FMath::FloorToInt((AccelXYRadians / TWO_PI) * 255.0); // [0, 2PI] -\u0026gt; [0, 255] ReplicatedAcceleration.AccelXYMagnitude = FMath::FloorToInt((AccelXYMagnitude / MaxAccel) * 255.0); // [0, MaxAccel] -\u0026gt; [0, 255] ReplicatedAcceleration.AccelZ = FMath::FloorToInt((CurrentAccel.Z / MaxAccel) * 127.0); // [-MaxAccel, MaxAccel] -\u0026gt; [-127, 127] } } Replicate 시키기 전 체크하는 단계인 PreReplication 함수에서 현재 캐릭터의 가속도와 관련된 값들을 가져와 계산한다.\n실수값들을 모두 FloorToInt 를 사용해 정수형으로 변환시키고, 값들을 (u)int8 형이 표현할 수 있는 값의 범위 내의 값으로 Normalized 시켰다.\n이제 ReplicatedAcceleration 안에 들어간 변수들은 모두 특정 값에 대한 Ratio 가 되었다.\n그것도 double이 아닌 1바이트 정수형으로 말이다.\n이렇게 실수형 변수를 정수형 변수로 변환하는 과정을 Quantization (양자화) 라고 한다.\n양자화를 하는 이유는 크게 3가지 정도인 것 같다.\n네트워크 전송 최적화 double 의 경우 8바이트, float의 경우 4바이트 값을 1바이트 정수형으로 보내 네트워크 부하를 줄일 수 있다. 계산 속도 최적화 실수형 계산은 생각보다 느리다. double의 경우엔 더 느리다. double로 저장된 8바이트(64비트) 짜리 변수를 1바이트(8비트) 로 경량화 했으므로, 계산 복잡도가 줄어든다. 정수형 계산이 실수형 계산보다 상대적으로 빠르기 때문에 사용할 수 있다. 메모리, 디스크 최적화 8바이트 가져와서 쓸걸 1바이트의 정보만 가져와서 계산한다면, 메모리와 디스크 사용량이 최적화될 것이다. 양자화한값을 실수형이던 본래값으로 다시 돌려내야한다면, 기존 값이 어떤 범위를 갖고있었는지 알아야한다.\n위에서 보는 2PI 나 MaxAccel 같은 값을 알아야 원래 값으로 되돌릴 수 있다.\n아래 함수에서는 양자화되어서 Replicated 된 변수들을 가져와 다시 기존 값으로 복구시키는 코드이다.\n양자화를 했던 방식에 대한 역산이 이뤄진다.\nvoid ALyraCharacter::OnRep_ReplicatedAcceleration() { if (ULyraCharacterMovementComponent* LyraMovementComponent = Cast\u0026lt;ULyraCharacterMovementComponent\u0026gt;(GetCharacterMovement())) { // Decompress Acceleration const double MaxAccel = LyraMovementComponent-\u0026gt;MaxAcceleration; const double AccelXYMagnitude = double(ReplicatedAcceleration.AccelXYMagnitude) * MaxAccel / 255.0; // [0, 255] -\u0026gt; [0, MaxAccel] const double AccelXYRadians = double(ReplicatedAcceleration.AccelXYRadians) * TWO_PI / 255.0; // [0, 255] -\u0026gt; [0, 2PI] FVector UnpackedAcceleration(FVector::ZeroVector); FMath::PolarToCartesian(AccelXYMagnitude, AccelXYRadians, UnpackedAcceleration.X, UnpackedAcceleration.Y); UnpackedAcceleration.Z = double(ReplicatedAcceleration.AccelZ) * MaxAccel / 127.0; // [-127, 127] -\u0026gt; [-MaxAccel, MaxAccel] LyraMovementComponent-\u0026gt;SetReplicatedAcceleration(UnpackedAcceleration); } } Lyra 프로젝트에 볼게 정말 많은 것 같다. 많이 배우는중.\nReference\nhttps://gaussian37.github.io/dl-concept-quantization/#quantization-%EC%9D%B4%EB%9E%80-1\n","date":"2022-04-23","permalink":"/posts/old-blog/quantized-%EC%96%91%EC%9E%90%ED%99%94-%EB%90%98%EC%97%88%EB%8B%A4%EB%8A%94-%EC%9D%98%EB%AF%B8%EC%99%80-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/","section":"Posts","summary":"Quantized (양자화) 되었다는 의미와 사용하는 이유","title":"Quantized (양자화) 되었다는 의미와 사용하는 이유"},{"content":"","date":"2022-04-23","permalink":"/tags/unreal-engine/","section":"Tags","summary":"","title":"Unreal Engine"},{"content":"","date":"2022-04-23","permalink":"/categories/unreal-engine/","section":"Categories","summary":"","title":"Unreal Engine"},{"content":"","date":"2022-04-22","permalink":"/categories/english-post/","section":"Categories","summary":"","title":"English Post"},{"content":"If you want to collect class-specific actors that spawned in the world you can use TActorIterator.\nfor (TActorIterator\u0026lt;ACharacter\u0026gt; Iter(GetWorld()); Iter; ++Iter) { ACharacter* Character = *Iter; //If IsValid Character-\u0026gt;Func(); } There is also a version of the Ranged For feature available in C++11.\nIt\u0026rsquo;s called TActorRange. With this, we can iterate it safer and easier.\nfor (ACharacter* Character : TActorRange\u0026lt;ACharacter\u0026gt;(GetWorld())) { //If IsValid Character-\u0026gt;Func(); } ","date":"2022-04-22","permalink":"/posts/tactoriterator-and-tactorrange/","section":"Posts","summary":"TActorIterator and TActorRange","title":"TActorIterator and TActorRange"},{"content":"","date":"2022-04-22","permalink":"/categories/unrealengine/","section":"Categories","summary":"","title":"UnrealEngine"},{"content":"언리얼의 경우 빌드 환경이 DebugGame 이 아닌 경우 (Development. Shipping) 에 성능은 거의 그대로 유지한체, 일부 디버깅이 필요한 영역만 컴파일 최적화를 꺼서 디버깅할 수 있다.\n일반 C++ 코드에도 그대로 적용 가능하다.\n#pragma optimize(\u0026quot;\u0026quot;, off) 이후 작성한 모든 코드에 대해 컴파일 최적화를 끄고,\n#pragma optimize(\u0026quot;\u0026quot;, on) 을 한 시점부터 컴파일 최적화가 다시 켜진다.\n//컴파일 최적화 비활성화 #pragma optimize(\u0026#34;\u0026#34;, off) void AVCharacter::SetRotationMode(EVRotationMode NewRotationMode) { //컴파일 최적화가 꺼져서 변수 내용들이 잘 보임 } //컴파일 최적화 활성화 #pragma optimize(\u0026#34;\u0026#34;, on) void AVCharacter::CalculateVisualScore() { //컴파일 최적화가 위에서 켜져서 변수 내용들이 잘 안 보임 } ","date":"2022-04-03","permalink":"/posts/old-blog/c-compile-optimization-%EC%9D%BC%EB%B6%80%EB%B6%84%EB%A7%8C-%ED%95%B4%EC%A0%9C%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/","section":"Posts","summary":"C++ Compile Optimization 일부분만 해제하는 방법","title":"C++ Compile Optimization 일부분만 해제하는 방법"},{"content":"If you want to debug your code while you didn\u0026rsquo;t compile your project with the DebugGame setting.\nYou might end up with see an optimized variable in which you can\u0026rsquo;t see what\u0026rsquo;s in it.\nIn that case, you can disable optimization on a specific section of your code.\nLike this.\n#pragma optimize(\u0026#34;\u0026#34;, off) void AVCharacter::NotOptimized() { //Some Codes } #pragma optimize(\u0026#34;\u0026#34;, on) void AVCharacter::Optimized() { //Some Codes } ","date":"2022-04-03","permalink":"/posts/controlling-c++-compile-optimization/","section":"Posts","summary":"Controlling C++ Compile Optimization","title":"Controlling C++ Compile Optimization"},{"content":"When you have multiple PIE viewports, you might have some viewport focus issues.\nFor example, having spectator to player and input mode change make viewports do ping pong each other.\nIt only happens in PIE mode because it\u0026rsquo;s not a Standalone Game.\nHere\u0026rsquo;s the code on how to check my viewport is in focus.\n#if UE_EDITOR UWorld* World = GetWorld(); if (IsValid(World) \u0026amp;\u0026amp; World-\u0026gt;WorldType == EWorldType::PIE) { UGameViewportClient* GameViewportClient = World-\u0026gt;GetGameViewport(); if (!IsValid(GameViewportClient)) return; if (IsValid(GEngine) \u0026amp;\u0026amp; IsValid(GEngine-\u0026gt;GameViewport) \u0026amp;\u0026amp; (GEngine-\u0026gt;GameViewport-\u0026gt;Viewport != nullptr)) { const bool bIsFocusedViewport = GameViewportClient-\u0026gt;IsFocused(GEngine-\u0026gt;GameViewport-\u0026gt;Viewport); UE_LOG(LogTemp, Log, TEXT(\u0026#34;%s\u0026#34;), (bIsFocusedViewport ? TEXT(\u0026#34;FOCUSED\u0026#34;) : TEXT(\u0026#34;NOT FOCUSED\u0026#34;))); } } #endif //UE_EDITOR Cheers!\n","date":"2022-03-05","permalink":"/posts/how-to-check-viewport-is-focused/","section":"Posts","summary":"How To Check Viewport Is Focused","title":"How To Check Viewport Is Focused"},{"content":"","date":"2021-12-12","permalink":"/tags/class/","section":"Tags","summary":"","title":"Class"},{"content":"It\u0026rsquo;s just simple. Just check with this code.\nGetClass()-\u0026gt;IsNative() You can test like this.\nFString Result = GetClass()-\u0026gt;IsNative() ? TEXT(\u0026#34; : NATIVE\u0026#34;) : TEXT(\u0026#34; : BLUEPRINT\u0026#34;); GEngine-\u0026gt;AddOnScreenDebugMessage(-1, 999.f, GetClass()-\u0026gt;IsNative() ? FColor::Yellow : FColor::Cyan, GetName() + Result); ","date":"2021-12-12","permalink":"/posts/how-to-check-class-is-from-native-or-blueprint/","section":"Posts","summary":"How To Check Class Is From Native Or Blueprint","title":"How To Check Class Is From Native Or Blueprint"},{"content":"","date":"2021-12-11","permalink":"/tags/enum/","section":"Tags","summary":"","title":"Enum"},{"content":"Sometimes we want to iterate over enum values.\nIn the Unreal Engine, We already have macros about making rages for UENUM.\nFirst, Let\u0026rsquo;s make a test enum type.\nUENUM(BlueprintType) enum class ETest : uint8 { ZERO, FIRST, SECOND, THIRD, FOURTH, FIFTH }; That looks decent enum type.\nWe also need to print the enum value name for the test.\ntemplate\u0026lt;typename TEnum\u0026gt; static FString EnumToString(const FString\u0026amp; Name, TEnum Value) { const UEnum* EnumPtr = FindObject\u0026lt;UEnum\u0026gt;(ANY_PACKAGE, *Name, true); if (UNLIKELY(!IsValid(EnumPtr))) return FString(\u0026#34;Invalid\u0026#34;); return EnumPtr-\u0026gt;GetNameStringByValue((int32)Value); } Okay, I think we\u0026rsquo;re ready! Let\u0026rsquo;s get into the topic.\nThere are 3 types of enum range macro.\nENUM_RANGE_BY_COUNT # This is a simple one.\nIt makes iterator range from the initial value to counted value.\nIf we declare a range like below, We\u0026rsquo;ll Iterator 3 elements from the initial value.\nENUM_RANGE_BY_COUNT(ETest, 3); Now we can iterate UENUM value with TEnumRange\u0026lt;\u0026gt; like this.\nfor (ETest Iter : TEnumRange\u0026lt;ETest\u0026gt;()) { GEngine-\u0026gt;AddOnScreenDebugMessage(-1, 999.f, FColor::Cyan, EnumToString\u0026lt;ETest\u0026gt;(\u0026#34;ETest\u0026#34;,Iter)); } You can see that we print only 3 elements.\nENUM_RANGE_BY_FIRST_AND_LAST # This version allows us to set the range scope ourselves.\nIf we declare a range like below, We\u0026rsquo;ll Iterator elements that from value to value.\nfrom 2(ETest::SECOND) to 5(ETest::FIFTH)\nENUM_RANGE_BY_FIRST_AND_LAST(ETest, 2, 5); You can see that we print from 2 to 5 value.\nENUM_RANGE_BY_VALUES # This version is quite interesting.\nLet\u0026rsquo;s say we make our enum values non-contiguous like this.\nUENUM(BlueprintType) enum class ETest : uint8 { ZERO = 0, FIRST = 3, SECOND = 5, THIRD = 10, FOURTH = 99, FIFTH = 128 }; We can\u0026rsquo;t use the macro that was explained before. Because this enum is non-contiguous.\nIf we declare macro like below, We\u0026rsquo;ll Iterator non-contiguous enum range with specific individual values.\nENUM_RANGE_BY_VALUES(ETest, ETest::FIRST, ETest::FOURTH); If you want to go deeper # You can find more details on these macro in EnumRange.h\nEngine\\Source\\Runtime\\Core\\Public\\Misc\\EnumRange.h\n","date":"2021-12-11","permalink":"/posts/how-to-iterate-over-uenum/","section":"Posts","summary":"Advanced Use of Unreal Engine Enumerator","title":"How To Iterate Over UENUM"},{"content":" Unreal Summit 2019 이득우 교수님 세션에도 나왔었다 ㅋㅋㅋㅋㅋㅋㅋㅋ 뿌-듯\n","date":"2019-07-03","permalink":"/posts/old-blog/awake-%EB%A5%BC-%EA%B0%9C%EB%B0%9C%ED%95%98%EB%A9%B0-%EA%B3%A0%EB%AF%BC%ED%96%88%EB%8D%98-%EC%96%B8%EB%A6%AC%EC%96%BC-%EC%97%94%EC%A7%84-%EB%B9%8C%EB%93%9C-%ED%83%80%EC%9E%84%EC%9D%84-%EC%A4%84/","section":"Posts","summary":"AWAKE 를 개발하며 고민했던 언리얼 엔진 빌드 타임을 줄이기 위한 시도들 (BUILD TIME KILLER)\u0026quot;","title":"AWAKE 를 개발하며 고민했던 언리얼 엔진 빌드 타임을 줄이기 위한 시도들 (BUILD TIME KILLER)"},{"content":" DISCLAIMER # 현 자료는 Epic Games의 Unreal Engine EVnagelist인 Chris Murphy님의 언리얼 서밋 2019 발표 자료 내용입니다. 모든 내용은 영상을 보며, 작성하였으며, 본인 개인의 공부 목적으로 간단하고 짧게 정리한 내용이라, 부정확한 정보가 존재하니 이점 유념하여 봐주시길 바랍니다.\n상단의 Help-\u0026gt;Console Variables에 들어가보면 에디터에서 사용할 수 있는 Console Command들을 HTML 페이지를 통해 검색해서 볼 수 있다.\n수학을 잘 모르는 개발자나 아트 직군을 위해서 Math Hall 이라는 수학 수식 안내용 맵이 존재한다.\n아트나 기획직군에게 엔지니어 멘토를 붙여주면 블루프린트를 이용한 워크플로에 많은 도움이 된다.\n오소그래픽 뷰포트에서 마우스 휠을 누르고 마우스를 움직이면 거리를 잴 수 있다. markup\nAlt+마우스 휠을 누르면 임시 Pivot을 설정해 물체의 Transform을 변경하기 아주 쉬워진다.\nCtrl_마우스 휠을 누르면서 드레그를 하면 뷰모드를 바꿀 수 있다. 방향마다 가는 뷰모드가 달라진다.\nShift+마우스 드레그를 하면 물체를 바라보고있던 카메라와 함께 움직인다.\nCtrl+마우스 버튼(왼쪽,오른쪽,둘다)을 누르면 물체의 위젯을 직접 잡지 않아도 움직일 수 있다.\nCtrl+\u0026rsquo;(Tilt)를 누면 로컬 좌표계와 월드 좌표계로 전환할 수 있다.\n오른쪽 클릭을 누르고 마우스휠을 올리거나 내리면 움직이는 속도를 바꿀 수 있다.\n떠있는 물체에다 End 키를 누르면 바닥에 붙는다.\n뷰포트 옵션 메뉴의 Layouts 탭에서 뷰포트를 나눌 수 있는 옵션이 있다.\nLandscape Grass Node 에서 지형의 식생 분포나 배치를 도와주는 노드가 있다.\n에디터 값 입력창에서 수식을 통해 값을 계산해 적용할 수있다. ex(1.0/2)를 Location 변수 지정에 사용가능.\nCall in Editor 이벤트 노드를 붙이면 동적으로 에디터 디테일 창에서 버튼을 통해 함수나 로직을 작동시킬 수 있다.\n머티리얼을 통해 Landscape를 만들 수 있다. Draw Material to Render Target 노드를 설정 후, Landscape Inport Heightmap form Render Target 노드를 사용하면 된다.\n물체를 흩어놔야하는 경우 Simulate Physics가 켜져있는 상태로 에디터를 플레이 해서 어지럽힌 후 K키를 누르면 그 위치에 고정되며, 에디터 플레이가 종료되어도 그 자리로 위치가 고정된다.\n콘텐츠 브라우저에서 검색 구문을 통해 더 세세하게 검색할 수 있다.\nAlt+Shift+O 키를 이용해 에셋 검색창을 바로 열 수 있다.\nBlutilities 라는 스크립팅 유틸리티가 있다. (플러그인 기본 비활성화)\n에디터 유틸리티 위젯이 있으며, Editor Widget을 만들어 게임 테스트 등을 위한 툴을 만들 수 있다.\nTick을 유의해 사용하자. 상황에 따라 타임라인, 타이머 등을 가급적 사용하고, 틱이 필요한 상황에서만 틱을 껏다 켜서 사용할 수 있도록 하며, Event Driven System을 만들자. Tick이 필요없는 엑터는 Actor Tick에서 Tick을 끄자, Blueprints 탭에서도 Can Blueprint Tick by Default를 끄도록 하자.\n게임이 잠깐씩 멈추는 것을 로그로 뽑아 볼 수 있다.\nt.HitchFrameTimeThreshold를 설정하면 볼 수 있다.\n콘텐츠 브라우저에서 폴더에 오른쪽 클릭을해서 Set Color를 하면 폴더의 색을 바꿀 수 있다.\n컬러 픽커를 통해 색을 고를 수 있다.\n버츄얼 카메라를 통해 핸드폰의 회전이나 위치를 동기화해서 게임속화면을 볼 수 있다.\n블루프린트 연결 노드를 Ctrl키를 누른뒤 잡으면 지우지 않고도 움직일 수 있다.\n이미 있는 지역변수를 오른쪽 클릭해서 Promote to Variable로 하면 변수로 설정할 수 있다.\n건틀렛(Gauntlet)프레임워크를 사용하면 멀티 플렛폼을 위한 빌드, 테스트 등등을 진행할 수있다.\nProcedural Foliage Tool을 사용해서 폴리지를 더 현실감있게 배치할 수 있다.\nVisualisation Modes를 통해 Deferred Render 버퍼의 모든 것을 볼 수 있다.\n맵 속 오브젝트를 누르고 복사해 메모장 같은 편집기에 불여넣으면 디테일 설정들이 복사되어 나타난다.\n마켓 플레이스에 Free Automotive Materials가 있다. (PBR 머티리얼들)\n마켓 플레이스에 Paragon 에셋들 전부 풀었다.\n오브젝트를 옮길 때, V키를 누르면 버텍스 스냅이 가능하다.\nPivot Painter 2를 쓸 수 있다. (Extra에서 설치해야함)\n모바일용 플러그인들이 존재한다. (사운드 볼륨, 배터리 잔량, 온도, GPS, 등등)\n로보리콜 모드킷 있으니까 함 써봐라 VR게임 만들면서 여러 샘플이나 참고자료를 만들어 두었다.\n로보리콜용 Behavior Tree 보면 공부 많이 될꺼다.\nEnvironmental Query System(EQS)로 맵상의 AI에게 지형에서도 정보를 얻을 수 있게 해준다.\n화면 분할 플레이모드가 있다.\nAnimation Fast Path라는 기능을 사용하면 변수 접근이 최적화되어, 퍼포먼스가 올라간다.\n(프로젝트 세팅에서 Optimize Anim Blueprint Member Variable Access)\nAsset sManagement Framework를 사용하면 에디터나 런타임에서 에셋을 로드하거나 찾을 수 있다. hard reference를 그만 사용할 수 있도록 해줌.\nVR에서는 포워드 렌더러 사용을 고려해봐라. VR은 포워드 렌더러에 최적화 해놨다. 그리고 그냥 게임들도 라이트 많이 없으면 포워드 렌더러 사용해봐라.\nLightweight Rigid Body Simulation이 있다. 캐릭터들의 시뮬레이션이 한 번에 많이 일어날 때 사용해라.\n대규모 월드를 만들 경우 월드 컴포지션 툴을 사용해라.(레벨 스트리밍에서 사용 불가)\n이펙트의 Overdraw를 조심해라. 파티클의 경우 Cutout 모드를 사용하는게 좋다.\n머티리얼 Draw Cost를 조사하라.\nr.rhicmdbpass 1\nr.rhithread.enable 0\nr.showmaterialdrawevents -1\nProfilegpu\n(항상 믿을만 한 것은 아님)\n머티리얼 함수를 레이어로 쓸 수 있다. (RGB에 따라 재질 머티리얼 설정 등등)\n스텐실 버퍼를 사용하면 에셋이 다른 버퍼에서 렌더링 될 수있도록 해준다. (VFX에 유용)\nPixel Depth Offset을 쓰면 오클루전 테스트를 렌더러 안에서 조정할 수 있다.(추가적인 약간의 오버헤드 발생)\nWorld Aligned Material을 만들어 쓰면 base UV를 무시하고 맵상에서 균일한 패턴을 얻을 수 있다. (자세한 건 모름)\nPre-Skinned Local Position/Normal. T-Pose의 위치를 캐시해 매시에 데칼이나 위장 머티리얼을 래핑할 필요없이 사용할 수 있다. (잘 모름)\nSun Position Calculator Plugin 이 있다. 블루프린트 엑터이고, 태양의 위치를 조정할 때 아주 좋다.\nMesh Decal은 간과할 거이 아니다. Masked된 메쉬와 거의 차이가 없다.\n자동 LOD 생성이 가능하다. 필요한 곳에 그룹으로 묶어 사용할 수도 있다.\nSkeletal Mesh도 LOD 생성이 가능하다.\nLow Latency Frame Syncing Mode를 사용하면 인풋 레이턴시를 줄일 수 있다.(잘 모름)\nr.OneFrameThreadLag는 항상 켜져있는 상태이고,\nr.GTSyncType 을 0,1,2 값으로 수정하며 사용한다.\n고해상도 스크린샷 촬영을 에디터 옵션탭에서 사용할 수 있다.\n쉐이더 컴파일이 오래 걸린다면 프로젝트 세팅에서 Shader Permutation을 비활성화 하도록 해보자.\n픽셀은 항상 문제가 되는 것이 아니다. (사진 첨부)\n블루프린트가 Hard Reference 되는 것을 피하라. 블루프린트가 다른 블루프린트를 레퍼런싱 한다면 그 블루프린트들은 모두 메모리에 로드될 것이다. 쌓이다 보면 겉잡을 수 없으니 미리 주의하라. 특히 게임이 느려지지는 않겠으나, 메모리나 로드타임이 오래걸리니 주의하라.\nPlotFunctionOnGraph 노드를 사용하면 현재 구성된 로직이 어떻게 변화하는지 그래프로 확인할 수 있다.\n프로젝트 세팅에서 Small Tool Bar Icons 를 사용하면, 툴바 아이콘들이 작아져 화면을 더 볼 수 있다. (프로같아보임)\n나이아가라 이펙트를 만들 때, 파티클은 Interpolated Spawning을 가능한 비활성화 하라. 오버헤드가 발생하며, 비활성화 하면 더 많은 파티클을 훨씬 적은 오버헤드로 생성 가능하다.\nVR Editor로 레벨 콘텐츠를 배치하거나 수정하거나 할 수 있다.\nAR 셋업용 팁. (사진 첨부)\n60. 자료 # 66. 자료 # 아죠시\u0026hellip; 100개가 아닌데요\u0026hellip;?\n","date":"2019-06-21","permalink":"/posts/old-blog/%EC%96%B8%EB%A6%AC%EC%96%BC-%EB%B2%A0%ED%85%8C%EB%9E%91%EC%9D%98-100%EA%B0%80%EC%A7%80-%ED%8C%81%EA%B3%BC-%ED%8A%B8%EB%A6%AD-%EC%A0%95%EB%A6%AC/","section":"Posts","summary":"언리얼 베테랑의 100가지 팁과 트릭 정리","title":"언리얼 베테랑의 100가지 팁과 트릭 정리"},{"content":"","date":"0001-01-01","permalink":"/topics/","section":"Topics","summary":"","title":"Topics"}]